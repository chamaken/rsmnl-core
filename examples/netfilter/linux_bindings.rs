#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

/* automatically generated by rust-bindgen 0.59.1 */
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const __UAPI_DEF_IF_IFCONF: u32 = 1;
pub const __UAPI_DEF_IF_IFMAP: u32 = 1;
pub const __UAPI_DEF_IF_IFNAMSIZ: u32 = 1;
pub const __UAPI_DEF_IF_IFREQ: u32 = 1;
pub const __UAPI_DEF_IF_NET_DEVICE_FLAGS: u32 = 1;
pub const __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO: u32 = 1;
pub const __UAPI_DEF_IN_ADDR: u32 = 1;
pub const __UAPI_DEF_IN_IPPROTO: u32 = 1;
pub const __UAPI_DEF_IN_PKTINFO: u32 = 1;
pub const __UAPI_DEF_IP_MREQ: u32 = 1;
pub const __UAPI_DEF_SOCKADDR_IN: u32 = 1;
pub const __UAPI_DEF_IN_CLASS: u32 = 1;
pub const __UAPI_DEF_IN6_ADDR: u32 = 1;
pub const __UAPI_DEF_IN6_ADDR_ALT: u32 = 1;
pub const __UAPI_DEF_SOCKADDR_IN6: u32 = 1;
pub const __UAPI_DEF_IPV6_MREQ: u32 = 1;
pub const __UAPI_DEF_IPPROTO_V6: u32 = 1;
pub const __UAPI_DEF_IPV6_OPTIONS: u32 = 1;
pub const __UAPI_DEF_IN6_PKTINFO: u32 = 1;
pub const __UAPI_DEF_IP6_MTUINFO: u32 = 1;
pub const __UAPI_DEF_SOCKADDR_IPX: u32 = 1;
pub const __UAPI_DEF_IPX_ROUTE_DEFINITION: u32 = 1;
pub const __UAPI_DEF_IPX_INTERFACE_DEFINITION: u32 = 1;
pub const __UAPI_DEF_IPX_CONFIG_DATA: u32 = 1;
pub const __UAPI_DEF_IPX_ROUTE_DEF: u32 = 1;
pub const __UAPI_DEF_XATTR: u32 = 1;
pub const _K_SS_MAXSIZE: u32 = 128;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_HDRINCL: u32 = 3;
pub const IP_OPTIONS: u32 = 4;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_RECVRETOPTS: u32 = 7;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_RECVERR_RFC4884: u32 = 26;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const __SOCK_SIZE__: u32 = 16;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_MULTICAST_NET: u32 = 3758096384;
pub const IN_CLASSE_NET: u32 = 4294967295;
pub const IN_CLASSE_NSHIFT: u32 = 0;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INADDR_LOOPBACK: u32 = 2130706433;
pub const INADDR_UNSPEC_GROUP: u32 = 3758096384;
pub const INADDR_ALLHOSTS_GROUP: u32 = 3758096385;
pub const INADDR_ALLRTRS_GROUP: u32 = 3758096386;
pub const INADDR_ALLSNOOPERS_GROUP: u32 = 3758096490;
pub const INADDR_MAX_LOCAL_GROUP: u32 = 3758096639;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const IPV6_FL_A_GET: u32 = 0;
pub const IPV6_FL_A_PUT: u32 = 1;
pub const IPV6_FL_A_RENEW: u32 = 2;
pub const IPV6_FL_F_CREATE: u32 = 1;
pub const IPV6_FL_F_EXCL: u32 = 2;
pub const IPV6_FL_F_REFLECT: u32 = 4;
pub const IPV6_FL_F_REMOTE: u32 = 8;
pub const IPV6_FL_S_NONE: u32 = 0;
pub const IPV6_FL_S_EXCL: u32 = 1;
pub const IPV6_FL_S_PROCESS: u32 = 2;
pub const IPV6_FL_S_USER: u32 = 3;
pub const IPV6_FL_S_ANY: u32 = 255;
pub const IPV6_FLOWINFO_FLOWLABEL: u32 = 1048575;
pub const IPV6_FLOWINFO_PRIORITY: u32 = 267386880;
pub const IPV6_PRIORITY_UNCHARACTERIZED: u32 = 0;
pub const IPV6_PRIORITY_FILLER: u32 = 256;
pub const IPV6_PRIORITY_UNATTENDED: u32 = 512;
pub const IPV6_PRIORITY_RESERVED1: u32 = 768;
pub const IPV6_PRIORITY_BULK: u32 = 1024;
pub const IPV6_PRIORITY_RESERVED2: u32 = 1280;
pub const IPV6_PRIORITY_INTERACTIVE: u32 = 1536;
pub const IPV6_PRIORITY_CONTROL: u32 = 1792;
pub const IPV6_PRIORITY_8: u32 = 2048;
pub const IPV6_PRIORITY_9: u32 = 2304;
pub const IPV6_PRIORITY_10: u32 = 2560;
pub const IPV6_PRIORITY_11: u32 = 2816;
pub const IPV6_PRIORITY_12: u32 = 3072;
pub const IPV6_PRIORITY_13: u32 = 3328;
pub const IPV6_PRIORITY_14: u32 = 3584;
pub const IPV6_PRIORITY_15: u32 = 3840;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_MH: u32 = 135;
pub const IPV6_TLV_PAD1: u32 = 0;
pub const IPV6_TLV_PADN: u32 = 1;
pub const IPV6_TLV_ROUTERALERT: u32 = 5;
pub const IPV6_TLV_CALIPSO: u32 = 7;
pub const IPV6_TLV_JUMBO: u32 = 194;
pub const IPV6_TLV_HAO: u32 = 201;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_FLOWINFO: u32 = 11;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_RECVERR_RFC4884: u32 = 31;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const IPV6_FLOWLABEL_MGR: u32 = 32;
pub const IPV6_FLOWINFO_SEND: u32 = 33;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_PREFER_SRC_TMP: u32 = 1;
pub const IPV6_PREFER_SRC_PUBLIC: u32 = 2;
pub const IPV6_PREFER_SRC_PUBTMP_DEFAULT: u32 = 256;
pub const IPV6_PREFER_SRC_COA: u32 = 4;
pub const IPV6_PREFER_SRC_HOME: u32 = 1024;
pub const IPV6_PREFER_SRC_CGA: u32 = 8;
pub const IPV6_PREFER_SRC_NONCGA: u32 = 2048;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const NF_DROP: u32 = 0;
pub const NF_ACCEPT: u32 = 1;
pub const NF_STOLEN: u32 = 2;
pub const NF_QUEUE: u32 = 3;
pub const NF_REPEAT: u32 = 4;
pub const NF_STOP: u32 = 5;
pub const NF_MAX_VERDICT: u32 = 5;
pub const NF_VERDICT_MASK: u32 = 255;
pub const NF_VERDICT_FLAG_QUEUE_BYPASS: u32 = 32768;
pub const NF_VERDICT_QMASK: u32 = 4294901760;
pub const NF_VERDICT_QBITS: u32 = 16;
pub const NF_VERDICT_BITS: u32 = 16;
pub const NF_CT_STATE_INVALID_BIT: u32 = 1;
pub const NF_CT_STATE_UNTRACKED_BIT: u32 = 64;
pub const NF_CT_EXPECT_PERMANENT: u32 = 1;
pub const NF_CT_EXPECT_INACTIVE: u32 = 2;
pub const NF_CT_EXPECT_USERSPACE: u32 = 4;
pub const IP_CT_TCP_FLAG_WINDOW_SCALE: u32 = 1;
pub const IP_CT_TCP_FLAG_SACK_PERM: u32 = 2;
pub const IP_CT_TCP_FLAG_CLOSE_INIT: u32 = 4;
pub const IP_CT_TCP_FLAG_BE_LIBERAL: u32 = 8;
pub const IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED: u32 = 16;
pub const IP_CT_TCP_FLAG_MAXACK_SET: u32 = 32;
pub const IP_CT_EXP_CHALLENGE_ACK: u32 = 64;
pub const IP_CT_TCP_SIMULTANEOUS_OPEN: u32 = 128;
pub const NF_NETLINK_CONNTRACK_NEW: u32 = 1;
pub const NF_NETLINK_CONNTRACK_UPDATE: u32 = 2;
pub const NF_NETLINK_CONNTRACK_DESTROY: u32 = 4;
pub const NF_NETLINK_CONNTRACK_EXP_NEW: u32 = 8;
pub const NF_NETLINK_CONNTRACK_EXP_UPDATE: u32 = 16;
pub const NF_NETLINK_CONNTRACK_EXP_DESTROY: u32 = 32;
pub const NFNL_NFA_NEST: u32 = 32768;
pub const NFA_ALIGNTO: u32 = 4;
pub const NFNETLINK_V0: u32 = 0;
pub const NFNL_SUBSYS_NONE: u32 = 0;
pub const NFNL_SUBSYS_CTNETLINK: u32 = 1;
pub const NFNL_SUBSYS_CTNETLINK_EXP: u32 = 2;
pub const NFNL_SUBSYS_QUEUE: u32 = 3;
pub const NFNL_SUBSYS_ULOG: u32 = 4;
pub const NFNL_SUBSYS_OSF: u32 = 5;
pub const NFNL_SUBSYS_IPSET: u32 = 6;
pub const NFNL_SUBSYS_ACCT: u32 = 7;
pub const NFNL_SUBSYS_CTNETLINK_TIMEOUT: u32 = 8;
pub const NFNL_SUBSYS_CTHELPER: u32 = 9;
pub const NFNL_SUBSYS_NFTABLES: u32 = 10;
pub const NFNL_SUBSYS_NFT_COMPAT: u32 = 11;
pub const NFNL_SUBSYS_COUNT: u32 = 12;
pub const NFULNL_COPY_NONE: u32 = 0;
pub const NFULNL_COPY_META: u32 = 1;
pub const NFULNL_COPY_PACKET: u32 = 2;
pub const NFULNL_CFG_F_SEQ: u32 = 1;
pub const NFULNL_CFG_F_SEQ_GLOBAL: u32 = 2;
pub const NFULNL_CFG_F_CONNTRACK: u32 = 4;
pub const NFQA_CFG_F_FAIL_OPEN: u32 = 1;
pub const NFQA_CFG_F_CONNTRACK: u32 = 2;
pub const NFQA_CFG_F_GSO: u32 = 4;
pub const NFQA_CFG_F_UID_GID: u32 = 8;
pub const NFQA_CFG_F_SECCTX: u32 = 16;
pub const NFQA_CFG_F_MAX: u32 = 32;
pub const NFQA_SKB_CSUMNOTREADY: u32 = 1;
pub const NFQA_SKB_GSO: u32 = 2;
pub const NFQA_SKB_CSUM_NOTVERIFIED: u32 = 4;
pub const NETLINK_ROUTE: u32 = 0;
pub const NETLINK_UNUSED: u32 = 1;
pub const NETLINK_USERSOCK: u32 = 2;
pub const NETLINK_FIREWALL: u32 = 3;
pub const NETLINK_SOCK_DIAG: u32 = 4;
pub const NETLINK_NFLOG: u32 = 5;
pub const NETLINK_XFRM: u32 = 6;
pub const NETLINK_SELINUX: u32 = 7;
pub const NETLINK_ISCSI: u32 = 8;
pub const NETLINK_AUDIT: u32 = 9;
pub const NETLINK_FIB_LOOKUP: u32 = 10;
pub const NETLINK_CONNECTOR: u32 = 11;
pub const NETLINK_NETFILTER: u32 = 12;
pub const NETLINK_IP6_FW: u32 = 13;
pub const NETLINK_DNRTMSG: u32 = 14;
pub const NETLINK_KOBJECT_UEVENT: u32 = 15;
pub const NETLINK_GENERIC: u32 = 16;
pub const NETLINK_SCSITRANSPORT: u32 = 18;
pub const NETLINK_ECRYPTFS: u32 = 19;
pub const NETLINK_RDMA: u32 = 20;
pub const NETLINK_CRYPTO: u32 = 21;
pub const NETLINK_SMC: u32 = 22;
pub const NETLINK_INET_DIAG: u32 = 4;
pub const MAX_LINKS: u32 = 32;
pub const NLM_F_REQUEST: u32 = 1;
pub const NLM_F_MULTI: u32 = 2;
pub const NLM_F_ACK: u32 = 4;
pub const NLM_F_ECHO: u32 = 8;
pub const NLM_F_DUMP_INTR: u32 = 16;
pub const NLM_F_DUMP_FILTERED: u32 = 32;
pub const NLM_F_ROOT: u32 = 256;
pub const NLM_F_MATCH: u32 = 512;
pub const NLM_F_ATOMIC: u32 = 1024;
pub const NLM_F_DUMP: u32 = 768;
pub const NLM_F_REPLACE: u32 = 256;
pub const NLM_F_EXCL: u32 = 512;
pub const NLM_F_CREATE: u32 = 1024;
pub const NLM_F_APPEND: u32 = 2048;
pub const NLM_F_NONREC: u32 = 256;
pub const NLM_F_CAPPED: u32 = 256;
pub const NLM_F_ACK_TLVS: u32 = 512;
pub const NLMSG_ALIGNTO: u32 = 4;
pub const NLMSG_NOOP: u32 = 1;
pub const NLMSG_ERROR: u32 = 2;
pub const NLMSG_DONE: u32 = 3;
pub const NLMSG_OVERRUN: u32 = 4;
pub const NLMSG_MIN_TYPE: u32 = 16;
pub const NETLINK_ADD_MEMBERSHIP: u32 = 1;
pub const NETLINK_DROP_MEMBERSHIP: u32 = 2;
pub const NETLINK_PKTINFO: u32 = 3;
pub const NETLINK_BROADCAST_ERROR: u32 = 4;
pub const NETLINK_NO_ENOBUFS: u32 = 5;
pub const NETLINK_RX_RING: u32 = 6;
pub const NETLINK_TX_RING: u32 = 7;
pub const NETLINK_LISTEN_ALL_NSID: u32 = 8;
pub const NETLINK_LIST_MEMBERSHIPS: u32 = 9;
pub const NETLINK_CAP_ACK: u32 = 10;
pub const NETLINK_EXT_ACK: u32 = 11;
pub const NETLINK_GET_STRICT_CHK: u32 = 12;
pub const NL_MMAP_MSG_ALIGNMENT: u32 = 4;
pub const NET_MAJOR: u32 = 36;
pub const NLA_F_NESTED: u32 = 32768;
pub const NLA_F_NET_BYTEORDER: u32 = 16384;
pub const NLA_TYPE_MASK: i32 = -49153;
pub const NLA_ALIGNTO: u32 = 4;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
pub type __kernel_sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_sockaddr_storage {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __kernel_sockaddr_storage__bindgen_ty_1 {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1,
    pub __align: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    pub ss_family: __kernel_sa_family_t,
    pub __data: [::std::os::raw::c_char; 126usize],
}
#[test]
fn bindgen_test_layout___kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1>()))
                .ss_family as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1>())).__data
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__data)
        )
    );
}
#[test]
fn bindgen_test_layout___kernel_sockaddr_storage__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_sockaddr_storage__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(__kernel_sockaddr_storage__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_sockaddr_storage__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__kernel_sockaddr_storage__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__kernel_sockaddr_storage__bindgen_ty_1>())).__align as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sockaddr_storage__bindgen_ty_1),
            "::",
            stringify!(__align)
        )
    );
}
#[test]
fn bindgen_test_layout___kernel_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_sockaddr_storage))
    );
}
pub const IPPROTO_IP: ::std::os::raw::c_uint = 0;
pub const IPPROTO_ICMP: ::std::os::raw::c_uint = 1;
pub const IPPROTO_IGMP: ::std::os::raw::c_uint = 2;
pub const IPPROTO_IPIP: ::std::os::raw::c_uint = 4;
pub const IPPROTO_TCP: ::std::os::raw::c_uint = 6;
pub const IPPROTO_EGP: ::std::os::raw::c_uint = 8;
pub const IPPROTO_PUP: ::std::os::raw::c_uint = 12;
pub const IPPROTO_UDP: ::std::os::raw::c_uint = 17;
pub const IPPROTO_IDP: ::std::os::raw::c_uint = 22;
pub const IPPROTO_TP: ::std::os::raw::c_uint = 29;
pub const IPPROTO_DCCP: ::std::os::raw::c_uint = 33;
pub const IPPROTO_IPV6: ::std::os::raw::c_uint = 41;
pub const IPPROTO_RSVP: ::std::os::raw::c_uint = 46;
pub const IPPROTO_GRE: ::std::os::raw::c_uint = 47;
pub const IPPROTO_ESP: ::std::os::raw::c_uint = 50;
pub const IPPROTO_AH: ::std::os::raw::c_uint = 51;
pub const IPPROTO_MTP: ::std::os::raw::c_uint = 92;
pub const IPPROTO_BEETPH: ::std::os::raw::c_uint = 94;
pub const IPPROTO_ENCAP: ::std::os::raw::c_uint = 98;
pub const IPPROTO_PIM: ::std::os::raw::c_uint = 103;
pub const IPPROTO_COMP: ::std::os::raw::c_uint = 108;
pub const IPPROTO_SCTP: ::std::os::raw::c_uint = 132;
pub const IPPROTO_UDPLITE: ::std::os::raw::c_uint = 136;
pub const IPPROTO_MPLS: ::std::os::raw::c_uint = 137;
pub const IPPROTO_ETHERNET: ::std::os::raw::c_uint = 143;
pub const IPPROTO_RAW: ::std::os::raw::c_uint = 255;
pub const IPPROTO_MPTCP: ::std::os::raw::c_uint = 262;
pub const IPPROTO_MAX: ::std::os::raw::c_uint = 263;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: __be32,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_address as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_ifindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: __be32,
    pub imr_interface: __be32,
    pub imr_sourceaddr: __be32,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_sourceaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: __be32,
    pub imsf_interface: __be32,
    pub imsf_fmode: __u32,
    pub imsf_numsrc: __u32,
    pub imsf_slist: [__be32; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(
        ::std::mem::size_of::<ip_msfilter>(),
        20usize,
        concat!("Size of: ", stringify!(ip_msfilter))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_msfilter>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_msfilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_fmode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_numsrc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_slist as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_slist)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_req {
    pub gr_interface: __u32,
    pub gr_group: __kernel_sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        136usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: __u32,
    pub gsr_group: __kernel_sockaddr_storage,
    pub gsr_source: __kernel_sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        264usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_source as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_filter {
    pub gf_interface: __u32,
    pub gf_group: __kernel_sockaddr_storage,
    pub gf_fmode: __u32,
    pub gf_numsrc: __u32,
    pub gf_slist: [__kernel_sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(
        ::std::mem::size_of::<group_filter>(),
        272usize,
        concat!("Size of: ", stringify!(group_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<group_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(group_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_fmode as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_numsrc as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_slist as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_slist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_ifindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_spec_dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: __kernel_sa_family_t,
    pub sin_port: __be16,
    pub sin_addr: in_addr,
    pub __pad: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).__pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub u6_addr8: [__u8; 16usize],
    pub u6_addr16: [__be16; 8usize],
    pub u6_addr32: [__be32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).u6_addr8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(in6_u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: ::std::os::raw::c_ushort,
    pub sin6_port: __be16,
    pub sin6_flowinfo: __be32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_ifindex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_flowlabel_req {
    pub flr_dst: in6_addr,
    pub flr_label: __be32,
    pub flr_action: __u8,
    pub flr_share: __u8,
    pub flr_flags: __u16,
    pub flr_expires: __u16,
    pub flr_linger: __u16,
    pub __flr_pad: __u32,
}
#[test]
fn bindgen_test_layout_in6_flowlabel_req() {
    assert_eq!(
        ::std::mem::size_of::<in6_flowlabel_req>(),
        32usize,
        concat!("Size of: ", stringify!(in6_flowlabel_req))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_flowlabel_req>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_flowlabel_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_flowlabel_req>())).flr_dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_flowlabel_req),
            "::",
            stringify!(flr_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_flowlabel_req>())).flr_label as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_flowlabel_req),
            "::",
            stringify!(flr_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_flowlabel_req>())).flr_action as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_flowlabel_req),
            "::",
            stringify!(flr_action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_flowlabel_req>())).flr_share as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_flowlabel_req),
            "::",
            stringify!(flr_share)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_flowlabel_req>())).flr_flags as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_flowlabel_req),
            "::",
            stringify!(flr_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_flowlabel_req>())).flr_expires as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_flowlabel_req),
            "::",
            stringify!(flr_expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_flowlabel_req>())).flr_linger as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_flowlabel_req),
            "::",
            stringify!(flr_linger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_flowlabel_req>())).__flr_pad as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_flowlabel_req),
            "::",
            stringify!(__flr_pad)
        )
    );
}
pub const nf_inet_hooks_NF_INET_PRE_ROUTING: nf_inet_hooks = 0;
pub const nf_inet_hooks_NF_INET_LOCAL_IN: nf_inet_hooks = 1;
pub const nf_inet_hooks_NF_INET_FORWARD: nf_inet_hooks = 2;
pub const nf_inet_hooks_NF_INET_LOCAL_OUT: nf_inet_hooks = 3;
pub const nf_inet_hooks_NF_INET_POST_ROUTING: nf_inet_hooks = 4;
pub const nf_inet_hooks_NF_INET_NUMHOOKS: nf_inet_hooks = 5;
pub const nf_inet_hooks_NF_INET_INGRESS: nf_inet_hooks = 5;
pub type nf_inet_hooks = ::std::os::raw::c_uint;
pub const nf_dev_hooks_NF_NETDEV_INGRESS: nf_dev_hooks = 0;
pub const nf_dev_hooks_NF_NETDEV_NUMHOOKS: nf_dev_hooks = 1;
pub type nf_dev_hooks = ::std::os::raw::c_uint;
pub const NFPROTO_UNSPEC: ::std::os::raw::c_uint = 0;
pub const NFPROTO_INET: ::std::os::raw::c_uint = 1;
pub const NFPROTO_IPV4: ::std::os::raw::c_uint = 2;
pub const NFPROTO_ARP: ::std::os::raw::c_uint = 3;
pub const NFPROTO_NETDEV: ::std::os::raw::c_uint = 5;
pub const NFPROTO_BRIDGE: ::std::os::raw::c_uint = 7;
pub const NFPROTO_IPV6: ::std::os::raw::c_uint = 10;
pub const NFPROTO_DECNET: ::std::os::raw::c_uint = 12;
pub const NFPROTO_NUMPROTO: ::std::os::raw::c_uint = 13;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_inet_addr {
    pub all: [__u32; 4usize],
    pub ip: __be32,
    pub ip6: [__be32; 4usize],
    pub in_: in_addr,
    pub in6: in6_addr,
}
#[test]
fn bindgen_test_layout_nf_inet_addr() {
    assert_eq!(
        ::std::mem::size_of::<nf_inet_addr>(),
        16usize,
        concat!("Size of: ", stringify!(nf_inet_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<nf_inet_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(nf_inet_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nf_inet_addr>())).all as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_inet_addr),
            "::",
            stringify!(all)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nf_inet_addr>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_inet_addr),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nf_inet_addr>())).ip6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_inet_addr),
            "::",
            stringify!(ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nf_inet_addr>())).in_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_inet_addr),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nf_inet_addr>())).in6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_inet_addr),
            "::",
            stringify!(in6)
        )
    );
}
pub const ip_conntrack_info_IP_CT_ESTABLISHED: ip_conntrack_info = 0;
pub const ip_conntrack_info_IP_CT_RELATED: ip_conntrack_info = 1;
pub const ip_conntrack_info_IP_CT_NEW: ip_conntrack_info = 2;
pub const ip_conntrack_info_IP_CT_IS_REPLY: ip_conntrack_info = 3;
pub const ip_conntrack_info_IP_CT_ESTABLISHED_REPLY: ip_conntrack_info = 3;
pub const ip_conntrack_info_IP_CT_RELATED_REPLY: ip_conntrack_info = 4;
pub const ip_conntrack_info_IP_CT_NUMBER: ip_conntrack_info = 5;
pub const ip_conntrack_info_IP_CT_NEW_REPLY: ip_conntrack_info = 5;
pub type ip_conntrack_info = ::std::os::raw::c_uint;
pub const ip_conntrack_status_IPS_EXPECTED_BIT: ip_conntrack_status = 0;
pub const ip_conntrack_status_IPS_EXPECTED: ip_conntrack_status = 1;
pub const ip_conntrack_status_IPS_SEEN_REPLY_BIT: ip_conntrack_status = 1;
pub const ip_conntrack_status_IPS_SEEN_REPLY: ip_conntrack_status = 2;
pub const ip_conntrack_status_IPS_ASSURED_BIT: ip_conntrack_status = 2;
pub const ip_conntrack_status_IPS_ASSURED: ip_conntrack_status = 4;
pub const ip_conntrack_status_IPS_CONFIRMED_BIT: ip_conntrack_status = 3;
pub const ip_conntrack_status_IPS_CONFIRMED: ip_conntrack_status = 8;
pub const ip_conntrack_status_IPS_SRC_NAT_BIT: ip_conntrack_status = 4;
pub const ip_conntrack_status_IPS_SRC_NAT: ip_conntrack_status = 16;
pub const ip_conntrack_status_IPS_DST_NAT_BIT: ip_conntrack_status = 5;
pub const ip_conntrack_status_IPS_DST_NAT: ip_conntrack_status = 32;
pub const ip_conntrack_status_IPS_NAT_MASK: ip_conntrack_status = 48;
pub const ip_conntrack_status_IPS_SEQ_ADJUST_BIT: ip_conntrack_status = 6;
pub const ip_conntrack_status_IPS_SEQ_ADJUST: ip_conntrack_status = 64;
pub const ip_conntrack_status_IPS_SRC_NAT_DONE_BIT: ip_conntrack_status = 7;
pub const ip_conntrack_status_IPS_SRC_NAT_DONE: ip_conntrack_status = 128;
pub const ip_conntrack_status_IPS_DST_NAT_DONE_BIT: ip_conntrack_status = 8;
pub const ip_conntrack_status_IPS_DST_NAT_DONE: ip_conntrack_status = 256;
pub const ip_conntrack_status_IPS_NAT_DONE_MASK: ip_conntrack_status = 384;
pub const ip_conntrack_status_IPS_DYING_BIT: ip_conntrack_status = 9;
pub const ip_conntrack_status_IPS_DYING: ip_conntrack_status = 512;
pub const ip_conntrack_status_IPS_FIXED_TIMEOUT_BIT: ip_conntrack_status = 10;
pub const ip_conntrack_status_IPS_FIXED_TIMEOUT: ip_conntrack_status = 1024;
pub const ip_conntrack_status_IPS_TEMPLATE_BIT: ip_conntrack_status = 11;
pub const ip_conntrack_status_IPS_TEMPLATE: ip_conntrack_status = 2048;
pub const ip_conntrack_status_IPS_UNTRACKED_BIT: ip_conntrack_status = 12;
pub const ip_conntrack_status_IPS_UNTRACKED: ip_conntrack_status = 4096;
pub const ip_conntrack_status_IPS_HELPER_BIT: ip_conntrack_status = 13;
pub const ip_conntrack_status_IPS_HELPER: ip_conntrack_status = 8192;
pub const ip_conntrack_status_IPS_OFFLOAD_BIT: ip_conntrack_status = 14;
pub const ip_conntrack_status_IPS_OFFLOAD: ip_conntrack_status = 16384;
pub const ip_conntrack_status_IPS_HW_OFFLOAD_BIT: ip_conntrack_status = 15;
pub const ip_conntrack_status_IPS_HW_OFFLOAD: ip_conntrack_status = 32768;
pub const ip_conntrack_status_IPS_UNCHANGEABLE_MASK: ip_conntrack_status = 56313;
pub const ip_conntrack_status___IPS_MAX_BIT: ip_conntrack_status = 16;
pub type ip_conntrack_status = ::std::os::raw::c_uint;
pub const ip_conntrack_events_IPCT_NEW: ip_conntrack_events = 0;
pub const ip_conntrack_events_IPCT_RELATED: ip_conntrack_events = 1;
pub const ip_conntrack_events_IPCT_DESTROY: ip_conntrack_events = 2;
pub const ip_conntrack_events_IPCT_REPLY: ip_conntrack_events = 3;
pub const ip_conntrack_events_IPCT_ASSURED: ip_conntrack_events = 4;
pub const ip_conntrack_events_IPCT_PROTOINFO: ip_conntrack_events = 5;
pub const ip_conntrack_events_IPCT_HELPER: ip_conntrack_events = 6;
pub const ip_conntrack_events_IPCT_MARK: ip_conntrack_events = 7;
pub const ip_conntrack_events_IPCT_SEQADJ: ip_conntrack_events = 8;
pub const ip_conntrack_events_IPCT_NATSEQADJ: ip_conntrack_events = 8;
pub const ip_conntrack_events_IPCT_SECMARK: ip_conntrack_events = 9;
pub const ip_conntrack_events_IPCT_LABEL: ip_conntrack_events = 10;
pub const ip_conntrack_events_IPCT_SYNPROXY: ip_conntrack_events = 11;
pub type ip_conntrack_events = ::std::os::raw::c_uint;
pub const ip_conntrack_expect_events_IPEXP_NEW: ip_conntrack_expect_events = 0;
pub const ip_conntrack_expect_events_IPEXP_DESTROY: ip_conntrack_expect_events = 1;
pub type ip_conntrack_expect_events = ::std::os::raw::c_uint;
pub const tcp_conntrack_TCP_CONNTRACK_NONE: tcp_conntrack = 0;
pub const tcp_conntrack_TCP_CONNTRACK_SYN_SENT: tcp_conntrack = 1;
pub const tcp_conntrack_TCP_CONNTRACK_SYN_RECV: tcp_conntrack = 2;
pub const tcp_conntrack_TCP_CONNTRACK_ESTABLISHED: tcp_conntrack = 3;
pub const tcp_conntrack_TCP_CONNTRACK_FIN_WAIT: tcp_conntrack = 4;
pub const tcp_conntrack_TCP_CONNTRACK_CLOSE_WAIT: tcp_conntrack = 5;
pub const tcp_conntrack_TCP_CONNTRACK_LAST_ACK: tcp_conntrack = 6;
pub const tcp_conntrack_TCP_CONNTRACK_TIME_WAIT: tcp_conntrack = 7;
pub const tcp_conntrack_TCP_CONNTRACK_CLOSE: tcp_conntrack = 8;
pub const tcp_conntrack_TCP_CONNTRACK_LISTEN: tcp_conntrack = 9;
pub const tcp_conntrack_TCP_CONNTRACK_MAX: tcp_conntrack = 10;
pub const tcp_conntrack_TCP_CONNTRACK_IGNORE: tcp_conntrack = 11;
pub const tcp_conntrack_TCP_CONNTRACK_RETRANS: tcp_conntrack = 12;
pub const tcp_conntrack_TCP_CONNTRACK_UNACK: tcp_conntrack = 13;
pub const tcp_conntrack_TCP_CONNTRACK_TIMEOUT_MAX: tcp_conntrack = 14;
pub type tcp_conntrack = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ct_tcp_flags {
    pub flags: __u8,
    pub mask: __u8,
}
#[test]
fn bindgen_test_layout_nf_ct_tcp_flags() {
    assert_eq!(
        ::std::mem::size_of::<nf_ct_tcp_flags>(),
        2usize,
        concat!("Size of: ", stringify!(nf_ct_tcp_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<nf_ct_tcp_flags>(),
        1usize,
        concat!("Alignment of ", stringify!(nf_ct_tcp_flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nf_ct_tcp_flags>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_ct_tcp_flags),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nf_ct_tcp_flags>())).mask as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_ct_tcp_flags),
            "::",
            stringify!(mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfattr {
    pub nfa_len: __u16,
    pub nfa_type: __u16,
}
#[test]
fn bindgen_test_layout_nfattr() {
    assert_eq!(
        ::std::mem::size_of::<nfattr>(),
        4usize,
        concat!("Size of: ", stringify!(nfattr))
    );
    assert_eq!(
        ::std::mem::align_of::<nfattr>(),
        2usize,
        concat!("Alignment of ", stringify!(nfattr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfattr>())).nfa_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfattr),
            "::",
            stringify!(nfa_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfattr>())).nfa_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nfattr),
            "::",
            stringify!(nfa_type)
        )
    );
}
pub const nfnetlink_groups_NFNLGRP_NONE: nfnetlink_groups = 0;
pub const nfnetlink_groups_NFNLGRP_CONNTRACK_NEW: nfnetlink_groups = 1;
pub const nfnetlink_groups_NFNLGRP_CONNTRACK_UPDATE: nfnetlink_groups = 2;
pub const nfnetlink_groups_NFNLGRP_CONNTRACK_DESTROY: nfnetlink_groups = 3;
pub const nfnetlink_groups_NFNLGRP_CONNTRACK_EXP_NEW: nfnetlink_groups = 4;
pub const nfnetlink_groups_NFNLGRP_CONNTRACK_EXP_UPDATE: nfnetlink_groups = 5;
pub const nfnetlink_groups_NFNLGRP_CONNTRACK_EXP_DESTROY: nfnetlink_groups = 6;
pub const nfnetlink_groups_NFNLGRP_NFTABLES: nfnetlink_groups = 7;
pub const nfnetlink_groups_NFNLGRP_ACCT_QUOTA: nfnetlink_groups = 8;
pub const nfnetlink_groups_NFNLGRP_NFTRACE: nfnetlink_groups = 9;
pub const nfnetlink_groups___NFNLGRP_MAX: nfnetlink_groups = 10;
pub type nfnetlink_groups = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfgenmsg {
    pub nfgen_family: __u8,
    pub version: __u8,
    pub res_id: __be16,
}
#[test]
fn bindgen_test_layout_nfgenmsg() {
    assert_eq!(
        ::std::mem::size_of::<nfgenmsg>(),
        4usize,
        concat!("Size of: ", stringify!(nfgenmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<nfgenmsg>(),
        2usize,
        concat!("Alignment of ", stringify!(nfgenmsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfgenmsg>())).nfgen_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfgenmsg),
            "::",
            stringify!(nfgen_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfgenmsg>())).version as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nfgenmsg),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfgenmsg>())).res_id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nfgenmsg),
            "::",
            stringify!(res_id)
        )
    );
}
pub const nfnl_batch_attributes_NFNL_BATCH_UNSPEC: nfnl_batch_attributes = 0;
pub const nfnl_batch_attributes_NFNL_BATCH_GENID: nfnl_batch_attributes = 1;
pub const nfnl_batch_attributes___NFNL_BATCH_MAX: nfnl_batch_attributes = 2;
pub type nfnl_batch_attributes = ::std::os::raw::c_uint;
pub const cntl_msg_types_IPCTNL_MSG_CT_NEW: cntl_msg_types = 0;
pub const cntl_msg_types_IPCTNL_MSG_CT_GET: cntl_msg_types = 1;
pub const cntl_msg_types_IPCTNL_MSG_CT_DELETE: cntl_msg_types = 2;
pub const cntl_msg_types_IPCTNL_MSG_CT_GET_CTRZERO: cntl_msg_types = 3;
pub const cntl_msg_types_IPCTNL_MSG_CT_GET_STATS_CPU: cntl_msg_types = 4;
pub const cntl_msg_types_IPCTNL_MSG_CT_GET_STATS: cntl_msg_types = 5;
pub const cntl_msg_types_IPCTNL_MSG_CT_GET_DYING: cntl_msg_types = 6;
pub const cntl_msg_types_IPCTNL_MSG_CT_GET_UNCONFIRMED: cntl_msg_types = 7;
pub const cntl_msg_types_IPCTNL_MSG_MAX: cntl_msg_types = 8;
pub type cntl_msg_types = ::std::os::raw::c_uint;
pub const ctnl_exp_msg_types_IPCTNL_MSG_EXP_NEW: ctnl_exp_msg_types = 0;
pub const ctnl_exp_msg_types_IPCTNL_MSG_EXP_GET: ctnl_exp_msg_types = 1;
pub const ctnl_exp_msg_types_IPCTNL_MSG_EXP_DELETE: ctnl_exp_msg_types = 2;
pub const ctnl_exp_msg_types_IPCTNL_MSG_EXP_GET_STATS_CPU: ctnl_exp_msg_types = 3;
pub const ctnl_exp_msg_types_IPCTNL_MSG_EXP_MAX: ctnl_exp_msg_types = 4;
pub type ctnl_exp_msg_types = ::std::os::raw::c_uint;
pub const ctattr_type_CTA_UNSPEC: ctattr_type = 0;
pub const ctattr_type_CTA_TUPLE_ORIG: ctattr_type = 1;
pub const ctattr_type_CTA_TUPLE_REPLY: ctattr_type = 2;
pub const ctattr_type_CTA_STATUS: ctattr_type = 3;
pub const ctattr_type_CTA_PROTOINFO: ctattr_type = 4;
pub const ctattr_type_CTA_HELP: ctattr_type = 5;
pub const ctattr_type_CTA_NAT_SRC: ctattr_type = 6;
pub const ctattr_type_CTA_TIMEOUT: ctattr_type = 7;
pub const ctattr_type_CTA_MARK: ctattr_type = 8;
pub const ctattr_type_CTA_COUNTERS_ORIG: ctattr_type = 9;
pub const ctattr_type_CTA_COUNTERS_REPLY: ctattr_type = 10;
pub const ctattr_type_CTA_USE: ctattr_type = 11;
pub const ctattr_type_CTA_ID: ctattr_type = 12;
pub const ctattr_type_CTA_NAT_DST: ctattr_type = 13;
pub const ctattr_type_CTA_TUPLE_MASTER: ctattr_type = 14;
pub const ctattr_type_CTA_SEQ_ADJ_ORIG: ctattr_type = 15;
pub const ctattr_type_CTA_NAT_SEQ_ADJ_ORIG: ctattr_type = 15;
pub const ctattr_type_CTA_SEQ_ADJ_REPLY: ctattr_type = 16;
pub const ctattr_type_CTA_NAT_SEQ_ADJ_REPLY: ctattr_type = 16;
pub const ctattr_type_CTA_SECMARK: ctattr_type = 17;
pub const ctattr_type_CTA_ZONE: ctattr_type = 18;
pub const ctattr_type_CTA_SECCTX: ctattr_type = 19;
pub const ctattr_type_CTA_TIMESTAMP: ctattr_type = 20;
pub const ctattr_type_CTA_MARK_MASK: ctattr_type = 21;
pub const ctattr_type_CTA_LABELS: ctattr_type = 22;
pub const ctattr_type_CTA_LABELS_MASK: ctattr_type = 23;
pub const ctattr_type_CTA_SYNPROXY: ctattr_type = 24;
pub const ctattr_type_CTA_FILTER: ctattr_type = 25;
pub const ctattr_type___CTA_MAX: ctattr_type = 26;
pub type ctattr_type = ::std::os::raw::c_uint;
pub const ctattr_tuple_CTA_TUPLE_UNSPEC: ctattr_tuple = 0;
pub const ctattr_tuple_CTA_TUPLE_IP: ctattr_tuple = 1;
pub const ctattr_tuple_CTA_TUPLE_PROTO: ctattr_tuple = 2;
pub const ctattr_tuple_CTA_TUPLE_ZONE: ctattr_tuple = 3;
pub const ctattr_tuple___CTA_TUPLE_MAX: ctattr_tuple = 4;
pub type ctattr_tuple = ::std::os::raw::c_uint;
pub const ctattr_ip_CTA_IP_UNSPEC: ctattr_ip = 0;
pub const ctattr_ip_CTA_IP_V4_SRC: ctattr_ip = 1;
pub const ctattr_ip_CTA_IP_V4_DST: ctattr_ip = 2;
pub const ctattr_ip_CTA_IP_V6_SRC: ctattr_ip = 3;
pub const ctattr_ip_CTA_IP_V6_DST: ctattr_ip = 4;
pub const ctattr_ip___CTA_IP_MAX: ctattr_ip = 5;
pub type ctattr_ip = ::std::os::raw::c_uint;
pub const ctattr_l4proto_CTA_PROTO_UNSPEC: ctattr_l4proto = 0;
pub const ctattr_l4proto_CTA_PROTO_NUM: ctattr_l4proto = 1;
pub const ctattr_l4proto_CTA_PROTO_SRC_PORT: ctattr_l4proto = 2;
pub const ctattr_l4proto_CTA_PROTO_DST_PORT: ctattr_l4proto = 3;
pub const ctattr_l4proto_CTA_PROTO_ICMP_ID: ctattr_l4proto = 4;
pub const ctattr_l4proto_CTA_PROTO_ICMP_TYPE: ctattr_l4proto = 5;
pub const ctattr_l4proto_CTA_PROTO_ICMP_CODE: ctattr_l4proto = 6;
pub const ctattr_l4proto_CTA_PROTO_ICMPV6_ID: ctattr_l4proto = 7;
pub const ctattr_l4proto_CTA_PROTO_ICMPV6_TYPE: ctattr_l4proto = 8;
pub const ctattr_l4proto_CTA_PROTO_ICMPV6_CODE: ctattr_l4proto = 9;
pub const ctattr_l4proto___CTA_PROTO_MAX: ctattr_l4proto = 10;
pub type ctattr_l4proto = ::std::os::raw::c_uint;
pub const ctattr_protoinfo_CTA_PROTOINFO_UNSPEC: ctattr_protoinfo = 0;
pub const ctattr_protoinfo_CTA_PROTOINFO_TCP: ctattr_protoinfo = 1;
pub const ctattr_protoinfo_CTA_PROTOINFO_DCCP: ctattr_protoinfo = 2;
pub const ctattr_protoinfo_CTA_PROTOINFO_SCTP: ctattr_protoinfo = 3;
pub const ctattr_protoinfo___CTA_PROTOINFO_MAX: ctattr_protoinfo = 4;
pub type ctattr_protoinfo = ::std::os::raw::c_uint;
pub const ctattr_protoinfo_tcp_CTA_PROTOINFO_TCP_UNSPEC: ctattr_protoinfo_tcp = 0;
pub const ctattr_protoinfo_tcp_CTA_PROTOINFO_TCP_STATE: ctattr_protoinfo_tcp = 1;
pub const ctattr_protoinfo_tcp_CTA_PROTOINFO_TCP_WSCALE_ORIGINAL: ctattr_protoinfo_tcp = 2;
pub const ctattr_protoinfo_tcp_CTA_PROTOINFO_TCP_WSCALE_REPLY: ctattr_protoinfo_tcp = 3;
pub const ctattr_protoinfo_tcp_CTA_PROTOINFO_TCP_FLAGS_ORIGINAL: ctattr_protoinfo_tcp = 4;
pub const ctattr_protoinfo_tcp_CTA_PROTOINFO_TCP_FLAGS_REPLY: ctattr_protoinfo_tcp = 5;
pub const ctattr_protoinfo_tcp___CTA_PROTOINFO_TCP_MAX: ctattr_protoinfo_tcp = 6;
pub type ctattr_protoinfo_tcp = ::std::os::raw::c_uint;
pub const ctattr_protoinfo_dccp_CTA_PROTOINFO_DCCP_UNSPEC: ctattr_protoinfo_dccp = 0;
pub const ctattr_protoinfo_dccp_CTA_PROTOINFO_DCCP_STATE: ctattr_protoinfo_dccp = 1;
pub const ctattr_protoinfo_dccp_CTA_PROTOINFO_DCCP_ROLE: ctattr_protoinfo_dccp = 2;
pub const ctattr_protoinfo_dccp_CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ: ctattr_protoinfo_dccp = 3;
pub const ctattr_protoinfo_dccp_CTA_PROTOINFO_DCCP_PAD: ctattr_protoinfo_dccp = 4;
pub const ctattr_protoinfo_dccp___CTA_PROTOINFO_DCCP_MAX: ctattr_protoinfo_dccp = 5;
pub type ctattr_protoinfo_dccp = ::std::os::raw::c_uint;
pub const ctattr_protoinfo_sctp_CTA_PROTOINFO_SCTP_UNSPEC: ctattr_protoinfo_sctp = 0;
pub const ctattr_protoinfo_sctp_CTA_PROTOINFO_SCTP_STATE: ctattr_protoinfo_sctp = 1;
pub const ctattr_protoinfo_sctp_CTA_PROTOINFO_SCTP_VTAG_ORIGINAL: ctattr_protoinfo_sctp = 2;
pub const ctattr_protoinfo_sctp_CTA_PROTOINFO_SCTP_VTAG_REPLY: ctattr_protoinfo_sctp = 3;
pub const ctattr_protoinfo_sctp___CTA_PROTOINFO_SCTP_MAX: ctattr_protoinfo_sctp = 4;
pub type ctattr_protoinfo_sctp = ::std::os::raw::c_uint;
pub const ctattr_counters_CTA_COUNTERS_UNSPEC: ctattr_counters = 0;
pub const ctattr_counters_CTA_COUNTERS_PACKETS: ctattr_counters = 1;
pub const ctattr_counters_CTA_COUNTERS_BYTES: ctattr_counters = 2;
pub const ctattr_counters_CTA_COUNTERS32_PACKETS: ctattr_counters = 3;
pub const ctattr_counters_CTA_COUNTERS32_BYTES: ctattr_counters = 4;
pub const ctattr_counters_CTA_COUNTERS_PAD: ctattr_counters = 5;
pub const ctattr_counters___CTA_COUNTERS_MAX: ctattr_counters = 6;
pub type ctattr_counters = ::std::os::raw::c_uint;
pub const ctattr_tstamp_CTA_TIMESTAMP_UNSPEC: ctattr_tstamp = 0;
pub const ctattr_tstamp_CTA_TIMESTAMP_START: ctattr_tstamp = 1;
pub const ctattr_tstamp_CTA_TIMESTAMP_STOP: ctattr_tstamp = 2;
pub const ctattr_tstamp_CTA_TIMESTAMP_PAD: ctattr_tstamp = 3;
pub const ctattr_tstamp___CTA_TIMESTAMP_MAX: ctattr_tstamp = 4;
pub type ctattr_tstamp = ::std::os::raw::c_uint;
pub const ctattr_nat_CTA_NAT_UNSPEC: ctattr_nat = 0;
pub const ctattr_nat_CTA_NAT_V4_MINIP: ctattr_nat = 1;
pub const ctattr_nat_CTA_NAT_V4_MAXIP: ctattr_nat = 2;
pub const ctattr_nat_CTA_NAT_PROTO: ctattr_nat = 3;
pub const ctattr_nat_CTA_NAT_V6_MINIP: ctattr_nat = 4;
pub const ctattr_nat_CTA_NAT_V6_MAXIP: ctattr_nat = 5;
pub const ctattr_nat___CTA_NAT_MAX: ctattr_nat = 6;
pub type ctattr_nat = ::std::os::raw::c_uint;
pub const ctattr_protonat_CTA_PROTONAT_UNSPEC: ctattr_protonat = 0;
pub const ctattr_protonat_CTA_PROTONAT_PORT_MIN: ctattr_protonat = 1;
pub const ctattr_protonat_CTA_PROTONAT_PORT_MAX: ctattr_protonat = 2;
pub const ctattr_protonat___CTA_PROTONAT_MAX: ctattr_protonat = 3;
pub type ctattr_protonat = ::std::os::raw::c_uint;
pub const ctattr_seqadj_CTA_SEQADJ_UNSPEC: ctattr_seqadj = 0;
pub const ctattr_seqadj_CTA_SEQADJ_CORRECTION_POS: ctattr_seqadj = 1;
pub const ctattr_seqadj_CTA_SEQADJ_OFFSET_BEFORE: ctattr_seqadj = 2;
pub const ctattr_seqadj_CTA_SEQADJ_OFFSET_AFTER: ctattr_seqadj = 3;
pub const ctattr_seqadj___CTA_SEQADJ_MAX: ctattr_seqadj = 4;
pub type ctattr_seqadj = ::std::os::raw::c_uint;
pub const ctattr_natseq_CTA_NAT_SEQ_UNSPEC: ctattr_natseq = 0;
pub const ctattr_natseq_CTA_NAT_SEQ_CORRECTION_POS: ctattr_natseq = 1;
pub const ctattr_natseq_CTA_NAT_SEQ_OFFSET_BEFORE: ctattr_natseq = 2;
pub const ctattr_natseq_CTA_NAT_SEQ_OFFSET_AFTER: ctattr_natseq = 3;
pub const ctattr_natseq___CTA_NAT_SEQ_MAX: ctattr_natseq = 4;
pub type ctattr_natseq = ::std::os::raw::c_uint;
pub const ctattr_synproxy_CTA_SYNPROXY_UNSPEC: ctattr_synproxy = 0;
pub const ctattr_synproxy_CTA_SYNPROXY_ISN: ctattr_synproxy = 1;
pub const ctattr_synproxy_CTA_SYNPROXY_ITS: ctattr_synproxy = 2;
pub const ctattr_synproxy_CTA_SYNPROXY_TSOFF: ctattr_synproxy = 3;
pub const ctattr_synproxy___CTA_SYNPROXY_MAX: ctattr_synproxy = 4;
pub type ctattr_synproxy = ::std::os::raw::c_uint;
pub const ctattr_expect_CTA_EXPECT_UNSPEC: ctattr_expect = 0;
pub const ctattr_expect_CTA_EXPECT_MASTER: ctattr_expect = 1;
pub const ctattr_expect_CTA_EXPECT_TUPLE: ctattr_expect = 2;
pub const ctattr_expect_CTA_EXPECT_MASK: ctattr_expect = 3;
pub const ctattr_expect_CTA_EXPECT_TIMEOUT: ctattr_expect = 4;
pub const ctattr_expect_CTA_EXPECT_ID: ctattr_expect = 5;
pub const ctattr_expect_CTA_EXPECT_HELP_NAME: ctattr_expect = 6;
pub const ctattr_expect_CTA_EXPECT_ZONE: ctattr_expect = 7;
pub const ctattr_expect_CTA_EXPECT_FLAGS: ctattr_expect = 8;
pub const ctattr_expect_CTA_EXPECT_CLASS: ctattr_expect = 9;
pub const ctattr_expect_CTA_EXPECT_NAT: ctattr_expect = 10;
pub const ctattr_expect_CTA_EXPECT_FN: ctattr_expect = 11;
pub const ctattr_expect___CTA_EXPECT_MAX: ctattr_expect = 12;
pub type ctattr_expect = ::std::os::raw::c_uint;
pub const ctattr_expect_nat_CTA_EXPECT_NAT_UNSPEC: ctattr_expect_nat = 0;
pub const ctattr_expect_nat_CTA_EXPECT_NAT_DIR: ctattr_expect_nat = 1;
pub const ctattr_expect_nat_CTA_EXPECT_NAT_TUPLE: ctattr_expect_nat = 2;
pub const ctattr_expect_nat___CTA_EXPECT_NAT_MAX: ctattr_expect_nat = 3;
pub type ctattr_expect_nat = ::std::os::raw::c_uint;
pub const ctattr_help_CTA_HELP_UNSPEC: ctattr_help = 0;
pub const ctattr_help_CTA_HELP_NAME: ctattr_help = 1;
pub const ctattr_help_CTA_HELP_INFO: ctattr_help = 2;
pub const ctattr_help___CTA_HELP_MAX: ctattr_help = 3;
pub type ctattr_help = ::std::os::raw::c_uint;
pub const ctattr_secctx_CTA_SECCTX_UNSPEC: ctattr_secctx = 0;
pub const ctattr_secctx_CTA_SECCTX_NAME: ctattr_secctx = 1;
pub const ctattr_secctx___CTA_SECCTX_MAX: ctattr_secctx = 2;
pub type ctattr_secctx = ::std::os::raw::c_uint;
pub const ctattr_stats_cpu_CTA_STATS_UNSPEC: ctattr_stats_cpu = 0;
pub const ctattr_stats_cpu_CTA_STATS_SEARCHED: ctattr_stats_cpu = 1;
pub const ctattr_stats_cpu_CTA_STATS_FOUND: ctattr_stats_cpu = 2;
pub const ctattr_stats_cpu_CTA_STATS_NEW: ctattr_stats_cpu = 3;
pub const ctattr_stats_cpu_CTA_STATS_INVALID: ctattr_stats_cpu = 4;
pub const ctattr_stats_cpu_CTA_STATS_IGNORE: ctattr_stats_cpu = 5;
pub const ctattr_stats_cpu_CTA_STATS_DELETE: ctattr_stats_cpu = 6;
pub const ctattr_stats_cpu_CTA_STATS_DELETE_LIST: ctattr_stats_cpu = 7;
pub const ctattr_stats_cpu_CTA_STATS_INSERT: ctattr_stats_cpu = 8;
pub const ctattr_stats_cpu_CTA_STATS_INSERT_FAILED: ctattr_stats_cpu = 9;
pub const ctattr_stats_cpu_CTA_STATS_DROP: ctattr_stats_cpu = 10;
pub const ctattr_stats_cpu_CTA_STATS_EARLY_DROP: ctattr_stats_cpu = 11;
pub const ctattr_stats_cpu_CTA_STATS_ERROR: ctattr_stats_cpu = 12;
pub const ctattr_stats_cpu_CTA_STATS_SEARCH_RESTART: ctattr_stats_cpu = 13;
pub const ctattr_stats_cpu_CTA_STATS_CLASH_RESOLVE: ctattr_stats_cpu = 14;
pub const ctattr_stats_cpu___CTA_STATS_MAX: ctattr_stats_cpu = 15;
pub type ctattr_stats_cpu = ::std::os::raw::c_uint;
pub const ctattr_stats_global_CTA_STATS_GLOBAL_UNSPEC: ctattr_stats_global = 0;
pub const ctattr_stats_global_CTA_STATS_GLOBAL_ENTRIES: ctattr_stats_global = 1;
pub const ctattr_stats_global_CTA_STATS_GLOBAL_MAX_ENTRIES: ctattr_stats_global = 2;
pub const ctattr_stats_global___CTA_STATS_GLOBAL_MAX: ctattr_stats_global = 3;
pub type ctattr_stats_global = ::std::os::raw::c_uint;
pub const ctattr_expect_stats_CTA_STATS_EXP_UNSPEC: ctattr_expect_stats = 0;
pub const ctattr_expect_stats_CTA_STATS_EXP_NEW: ctattr_expect_stats = 1;
pub const ctattr_expect_stats_CTA_STATS_EXP_CREATE: ctattr_expect_stats = 2;
pub const ctattr_expect_stats_CTA_STATS_EXP_DELETE: ctattr_expect_stats = 3;
pub const ctattr_expect_stats___CTA_STATS_EXP_MAX: ctattr_expect_stats = 4;
pub type ctattr_expect_stats = ::std::os::raw::c_uint;
pub const ctattr_filter_CTA_FILTER_UNSPEC: ctattr_filter = 0;
pub const ctattr_filter_CTA_FILTER_ORIG_FLAGS: ctattr_filter = 1;
pub const ctattr_filter_CTA_FILTER_REPLY_FLAGS: ctattr_filter = 2;
pub const ctattr_filter___CTA_FILTER_MAX: ctattr_filter = 3;
pub type ctattr_filter = ::std::os::raw::c_uint;
pub const nfulnl_msg_types_NFULNL_MSG_PACKET: nfulnl_msg_types = 0;
pub const nfulnl_msg_types_NFULNL_MSG_CONFIG: nfulnl_msg_types = 1;
pub const nfulnl_msg_types_NFULNL_MSG_MAX: nfulnl_msg_types = 2;
pub type nfulnl_msg_types = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfulnl_msg_packet_hdr {
    pub hw_protocol: __be16,
    pub hook: __u8,
    pub _pad: __u8,
}
#[test]
fn bindgen_test_layout_nfulnl_msg_packet_hdr() {
    assert_eq!(
        ::std::mem::size_of::<nfulnl_msg_packet_hdr>(),
        4usize,
        concat!("Size of: ", stringify!(nfulnl_msg_packet_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<nfulnl_msg_packet_hdr>(),
        2usize,
        concat!("Alignment of ", stringify!(nfulnl_msg_packet_hdr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nfulnl_msg_packet_hdr>())).hw_protocol as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfulnl_msg_packet_hdr),
            "::",
            stringify!(hw_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfulnl_msg_packet_hdr>())).hook as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nfulnl_msg_packet_hdr),
            "::",
            stringify!(hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfulnl_msg_packet_hdr>()))._pad as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(nfulnl_msg_packet_hdr),
            "::",
            stringify!(_pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfulnl_msg_packet_hw {
    pub hw_addrlen: __be16,
    pub _pad: __u16,
    pub hw_addr: [__u8; 8usize],
}
#[test]
fn bindgen_test_layout_nfulnl_msg_packet_hw() {
    assert_eq!(
        ::std::mem::size_of::<nfulnl_msg_packet_hw>(),
        12usize,
        concat!("Size of: ", stringify!(nfulnl_msg_packet_hw))
    );
    assert_eq!(
        ::std::mem::align_of::<nfulnl_msg_packet_hw>(),
        2usize,
        concat!("Alignment of ", stringify!(nfulnl_msg_packet_hw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfulnl_msg_packet_hw>())).hw_addrlen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfulnl_msg_packet_hw),
            "::",
            stringify!(hw_addrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfulnl_msg_packet_hw>()))._pad as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nfulnl_msg_packet_hw),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfulnl_msg_packet_hw>())).hw_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nfulnl_msg_packet_hw),
            "::",
            stringify!(hw_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfulnl_msg_packet_timestamp {
    pub sec: __be64,
    pub usec: __be64,
}
#[test]
fn bindgen_test_layout_nfulnl_msg_packet_timestamp() {
    assert_eq!(
        ::std::mem::size_of::<nfulnl_msg_packet_timestamp>(),
        16usize,
        concat!("Size of: ", stringify!(nfulnl_msg_packet_timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<nfulnl_msg_packet_timestamp>(),
        8usize,
        concat!("Alignment of ", stringify!(nfulnl_msg_packet_timestamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfulnl_msg_packet_timestamp>())).sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfulnl_msg_packet_timestamp),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nfulnl_msg_packet_timestamp>())).usec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nfulnl_msg_packet_timestamp),
            "::",
            stringify!(usec)
        )
    );
}
pub const nfulnl_vlan_attr_NFULA_VLAN_UNSPEC: nfulnl_vlan_attr = 0;
pub const nfulnl_vlan_attr_NFULA_VLAN_PROTO: nfulnl_vlan_attr = 1;
pub const nfulnl_vlan_attr_NFULA_VLAN_TCI: nfulnl_vlan_attr = 2;
pub const nfulnl_vlan_attr___NFULA_VLAN_MAX: nfulnl_vlan_attr = 3;
pub type nfulnl_vlan_attr = ::std::os::raw::c_uint;
pub const nfulnl_attr_type_NFULA_UNSPEC: nfulnl_attr_type = 0;
pub const nfulnl_attr_type_NFULA_PACKET_HDR: nfulnl_attr_type = 1;
pub const nfulnl_attr_type_NFULA_MARK: nfulnl_attr_type = 2;
pub const nfulnl_attr_type_NFULA_TIMESTAMP: nfulnl_attr_type = 3;
pub const nfulnl_attr_type_NFULA_IFINDEX_INDEV: nfulnl_attr_type = 4;
pub const nfulnl_attr_type_NFULA_IFINDEX_OUTDEV: nfulnl_attr_type = 5;
pub const nfulnl_attr_type_NFULA_IFINDEX_PHYSINDEV: nfulnl_attr_type = 6;
pub const nfulnl_attr_type_NFULA_IFINDEX_PHYSOUTDEV: nfulnl_attr_type = 7;
pub const nfulnl_attr_type_NFULA_HWADDR: nfulnl_attr_type = 8;
pub const nfulnl_attr_type_NFULA_PAYLOAD: nfulnl_attr_type = 9;
pub const nfulnl_attr_type_NFULA_PREFIX: nfulnl_attr_type = 10;
pub const nfulnl_attr_type_NFULA_UID: nfulnl_attr_type = 11;
pub const nfulnl_attr_type_NFULA_SEQ: nfulnl_attr_type = 12;
pub const nfulnl_attr_type_NFULA_SEQ_GLOBAL: nfulnl_attr_type = 13;
pub const nfulnl_attr_type_NFULA_GID: nfulnl_attr_type = 14;
pub const nfulnl_attr_type_NFULA_HWTYPE: nfulnl_attr_type = 15;
pub const nfulnl_attr_type_NFULA_HWHEADER: nfulnl_attr_type = 16;
pub const nfulnl_attr_type_NFULA_HWLEN: nfulnl_attr_type = 17;
pub const nfulnl_attr_type_NFULA_CT: nfulnl_attr_type = 18;
pub const nfulnl_attr_type_NFULA_CT_INFO: nfulnl_attr_type = 19;
pub const nfulnl_attr_type_NFULA_VLAN: nfulnl_attr_type = 20;
pub const nfulnl_attr_type_NFULA_L2HDR: nfulnl_attr_type = 21;
pub const nfulnl_attr_type___NFULA_MAX: nfulnl_attr_type = 22;
pub type nfulnl_attr_type = ::std::os::raw::c_uint;
pub const nfulnl_msg_config_cmds_NFULNL_CFG_CMD_NONE: nfulnl_msg_config_cmds = 0;
pub const nfulnl_msg_config_cmds_NFULNL_CFG_CMD_BIND: nfulnl_msg_config_cmds = 1;
pub const nfulnl_msg_config_cmds_NFULNL_CFG_CMD_UNBIND: nfulnl_msg_config_cmds = 2;
pub const nfulnl_msg_config_cmds_NFULNL_CFG_CMD_PF_BIND: nfulnl_msg_config_cmds = 3;
pub const nfulnl_msg_config_cmds_NFULNL_CFG_CMD_PF_UNBIND: nfulnl_msg_config_cmds = 4;
pub type nfulnl_msg_config_cmds = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nfulnl_msg_config_cmd {
    pub command: __u8,
}
#[test]
fn bindgen_test_layout_nfulnl_msg_config_cmd() {
    assert_eq!(
        ::std::mem::size_of::<nfulnl_msg_config_cmd>(),
        1usize,
        concat!("Size of: ", stringify!(nfulnl_msg_config_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<nfulnl_msg_config_cmd>(),
        1usize,
        concat!("Alignment of ", stringify!(nfulnl_msg_config_cmd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfulnl_msg_config_cmd>())).command as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfulnl_msg_config_cmd),
            "::",
            stringify!(command)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nfulnl_msg_config_mode {
    pub copy_range: __be32,
    pub copy_mode: __u8,
    pub _pad: __u8,
}
#[test]
fn bindgen_test_layout_nfulnl_msg_config_mode() {
    assert_eq!(
        ::std::mem::size_of::<nfulnl_msg_config_mode>(),
        6usize,
        concat!("Size of: ", stringify!(nfulnl_msg_config_mode))
    );
    assert_eq!(
        ::std::mem::align_of::<nfulnl_msg_config_mode>(),
        1usize,
        concat!("Alignment of ", stringify!(nfulnl_msg_config_mode))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nfulnl_msg_config_mode>())).copy_range as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfulnl_msg_config_mode),
            "::",
            stringify!(copy_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nfulnl_msg_config_mode>())).copy_mode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nfulnl_msg_config_mode),
            "::",
            stringify!(copy_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfulnl_msg_config_mode>()))._pad as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(nfulnl_msg_config_mode),
            "::",
            stringify!(_pad)
        )
    );
}
pub const nfulnl_attr_config_NFULA_CFG_UNSPEC: nfulnl_attr_config = 0;
pub const nfulnl_attr_config_NFULA_CFG_CMD: nfulnl_attr_config = 1;
pub const nfulnl_attr_config_NFULA_CFG_MODE: nfulnl_attr_config = 2;
pub const nfulnl_attr_config_NFULA_CFG_NLBUFSIZ: nfulnl_attr_config = 3;
pub const nfulnl_attr_config_NFULA_CFG_TIMEOUT: nfulnl_attr_config = 4;
pub const nfulnl_attr_config_NFULA_CFG_QTHRESH: nfulnl_attr_config = 5;
pub const nfulnl_attr_config_NFULA_CFG_FLAGS: nfulnl_attr_config = 6;
pub const nfulnl_attr_config___NFULA_CFG_MAX: nfulnl_attr_config = 7;
pub type nfulnl_attr_config = ::std::os::raw::c_uint;
pub const nfqnl_msg_types_NFQNL_MSG_PACKET: nfqnl_msg_types = 0;
pub const nfqnl_msg_types_NFQNL_MSG_VERDICT: nfqnl_msg_types = 1;
pub const nfqnl_msg_types_NFQNL_MSG_CONFIG: nfqnl_msg_types = 2;
pub const nfqnl_msg_types_NFQNL_MSG_VERDICT_BATCH: nfqnl_msg_types = 3;
pub const nfqnl_msg_types_NFQNL_MSG_MAX: nfqnl_msg_types = 4;
pub type nfqnl_msg_types = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nfqnl_msg_packet_hdr {
    pub packet_id: __be32,
    pub hw_protocol: __be16,
    pub hook: __u8,
}
#[test]
fn bindgen_test_layout_nfqnl_msg_packet_hdr() {
    assert_eq!(
        ::std::mem::size_of::<nfqnl_msg_packet_hdr>(),
        7usize,
        concat!("Size of: ", stringify!(nfqnl_msg_packet_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<nfqnl_msg_packet_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(nfqnl_msg_packet_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfqnl_msg_packet_hdr>())).packet_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_packet_hdr),
            "::",
            stringify!(packet_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nfqnl_msg_packet_hdr>())).hw_protocol as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_packet_hdr),
            "::",
            stringify!(hw_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfqnl_msg_packet_hdr>())).hook as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_packet_hdr),
            "::",
            stringify!(hook)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfqnl_msg_packet_hw {
    pub hw_addrlen: __be16,
    pub _pad: __u16,
    pub hw_addr: [__u8; 8usize],
}
#[test]
fn bindgen_test_layout_nfqnl_msg_packet_hw() {
    assert_eq!(
        ::std::mem::size_of::<nfqnl_msg_packet_hw>(),
        12usize,
        concat!("Size of: ", stringify!(nfqnl_msg_packet_hw))
    );
    assert_eq!(
        ::std::mem::align_of::<nfqnl_msg_packet_hw>(),
        2usize,
        concat!("Alignment of ", stringify!(nfqnl_msg_packet_hw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfqnl_msg_packet_hw>())).hw_addrlen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_packet_hw),
            "::",
            stringify!(hw_addrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfqnl_msg_packet_hw>()))._pad as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_packet_hw),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfqnl_msg_packet_hw>())).hw_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_packet_hw),
            "::",
            stringify!(hw_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfqnl_msg_packet_timestamp {
    pub sec: __be64,
    pub usec: __be64,
}
#[test]
fn bindgen_test_layout_nfqnl_msg_packet_timestamp() {
    assert_eq!(
        ::std::mem::size_of::<nfqnl_msg_packet_timestamp>(),
        16usize,
        concat!("Size of: ", stringify!(nfqnl_msg_packet_timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<nfqnl_msg_packet_timestamp>(),
        8usize,
        concat!("Alignment of ", stringify!(nfqnl_msg_packet_timestamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfqnl_msg_packet_timestamp>())).sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_packet_timestamp),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfqnl_msg_packet_timestamp>())).usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_packet_timestamp),
            "::",
            stringify!(usec)
        )
    );
}
pub const nfqnl_vlan_attr_NFQA_VLAN_UNSPEC: nfqnl_vlan_attr = 0;
pub const nfqnl_vlan_attr_NFQA_VLAN_PROTO: nfqnl_vlan_attr = 1;
pub const nfqnl_vlan_attr_NFQA_VLAN_TCI: nfqnl_vlan_attr = 2;
pub const nfqnl_vlan_attr___NFQA_VLAN_MAX: nfqnl_vlan_attr = 3;
pub type nfqnl_vlan_attr = ::std::os::raw::c_uint;
pub const nfqnl_attr_type_NFQA_UNSPEC: nfqnl_attr_type = 0;
pub const nfqnl_attr_type_NFQA_PACKET_HDR: nfqnl_attr_type = 1;
pub const nfqnl_attr_type_NFQA_VERDICT_HDR: nfqnl_attr_type = 2;
pub const nfqnl_attr_type_NFQA_MARK: nfqnl_attr_type = 3;
pub const nfqnl_attr_type_NFQA_TIMESTAMP: nfqnl_attr_type = 4;
pub const nfqnl_attr_type_NFQA_IFINDEX_INDEV: nfqnl_attr_type = 5;
pub const nfqnl_attr_type_NFQA_IFINDEX_OUTDEV: nfqnl_attr_type = 6;
pub const nfqnl_attr_type_NFQA_IFINDEX_PHYSINDEV: nfqnl_attr_type = 7;
pub const nfqnl_attr_type_NFQA_IFINDEX_PHYSOUTDEV: nfqnl_attr_type = 8;
pub const nfqnl_attr_type_NFQA_HWADDR: nfqnl_attr_type = 9;
pub const nfqnl_attr_type_NFQA_PAYLOAD: nfqnl_attr_type = 10;
pub const nfqnl_attr_type_NFQA_CT: nfqnl_attr_type = 11;
pub const nfqnl_attr_type_NFQA_CT_INFO: nfqnl_attr_type = 12;
pub const nfqnl_attr_type_NFQA_CAP_LEN: nfqnl_attr_type = 13;
pub const nfqnl_attr_type_NFQA_SKB_INFO: nfqnl_attr_type = 14;
pub const nfqnl_attr_type_NFQA_EXP: nfqnl_attr_type = 15;
pub const nfqnl_attr_type_NFQA_UID: nfqnl_attr_type = 16;
pub const nfqnl_attr_type_NFQA_GID: nfqnl_attr_type = 17;
pub const nfqnl_attr_type_NFQA_SECCTX: nfqnl_attr_type = 18;
pub const nfqnl_attr_type_NFQA_VLAN: nfqnl_attr_type = 19;
pub const nfqnl_attr_type_NFQA_L2HDR: nfqnl_attr_type = 20;
pub const nfqnl_attr_type___NFQA_MAX: nfqnl_attr_type = 21;
pub type nfqnl_attr_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfqnl_msg_verdict_hdr {
    pub verdict: __be32,
    pub id: __be32,
}
#[test]
fn bindgen_test_layout_nfqnl_msg_verdict_hdr() {
    assert_eq!(
        ::std::mem::size_of::<nfqnl_msg_verdict_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(nfqnl_msg_verdict_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<nfqnl_msg_verdict_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(nfqnl_msg_verdict_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfqnl_msg_verdict_hdr>())).verdict as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_verdict_hdr),
            "::",
            stringify!(verdict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfqnl_msg_verdict_hdr>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_verdict_hdr),
            "::",
            stringify!(id)
        )
    );
}
pub const nfqnl_msg_config_cmds_NFQNL_CFG_CMD_NONE: nfqnl_msg_config_cmds = 0;
pub const nfqnl_msg_config_cmds_NFQNL_CFG_CMD_BIND: nfqnl_msg_config_cmds = 1;
pub const nfqnl_msg_config_cmds_NFQNL_CFG_CMD_UNBIND: nfqnl_msg_config_cmds = 2;
pub const nfqnl_msg_config_cmds_NFQNL_CFG_CMD_PF_BIND: nfqnl_msg_config_cmds = 3;
pub const nfqnl_msg_config_cmds_NFQNL_CFG_CMD_PF_UNBIND: nfqnl_msg_config_cmds = 4;
pub type nfqnl_msg_config_cmds = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfqnl_msg_config_cmd {
    pub command: __u8,
    pub _pad: __u8,
    pub pf: __be16,
}
#[test]
fn bindgen_test_layout_nfqnl_msg_config_cmd() {
    assert_eq!(
        ::std::mem::size_of::<nfqnl_msg_config_cmd>(),
        4usize,
        concat!("Size of: ", stringify!(nfqnl_msg_config_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<nfqnl_msg_config_cmd>(),
        2usize,
        concat!("Alignment of ", stringify!(nfqnl_msg_config_cmd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfqnl_msg_config_cmd>())).command as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_config_cmd),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfqnl_msg_config_cmd>()))._pad as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_config_cmd),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfqnl_msg_config_cmd>())).pf as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_config_cmd),
            "::",
            stringify!(pf)
        )
    );
}
pub const nfqnl_config_mode_NFQNL_COPY_NONE: nfqnl_config_mode = 0;
pub const nfqnl_config_mode_NFQNL_COPY_META: nfqnl_config_mode = 1;
pub const nfqnl_config_mode_NFQNL_COPY_PACKET: nfqnl_config_mode = 2;
pub type nfqnl_config_mode = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nfqnl_msg_config_params {
    pub copy_range: __be32,
    pub copy_mode: __u8,
}
#[test]
fn bindgen_test_layout_nfqnl_msg_config_params() {
    assert_eq!(
        ::std::mem::size_of::<nfqnl_msg_config_params>(),
        5usize,
        concat!("Size of: ", stringify!(nfqnl_msg_config_params))
    );
    assert_eq!(
        ::std::mem::align_of::<nfqnl_msg_config_params>(),
        1usize,
        concat!("Alignment of ", stringify!(nfqnl_msg_config_params))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nfqnl_msg_config_params>())).copy_range as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_config_params),
            "::",
            stringify!(copy_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nfqnl_msg_config_params>())).copy_mode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nfqnl_msg_config_params),
            "::",
            stringify!(copy_mode)
        )
    );
}
pub const nfqnl_attr_config_NFQA_CFG_UNSPEC: nfqnl_attr_config = 0;
pub const nfqnl_attr_config_NFQA_CFG_CMD: nfqnl_attr_config = 1;
pub const nfqnl_attr_config_NFQA_CFG_PARAMS: nfqnl_attr_config = 2;
pub const nfqnl_attr_config_NFQA_CFG_QUEUE_MAXLEN: nfqnl_attr_config = 3;
pub const nfqnl_attr_config_NFQA_CFG_MASK: nfqnl_attr_config = 4;
pub const nfqnl_attr_config_NFQA_CFG_FLAGS: nfqnl_attr_config = 5;
pub const nfqnl_attr_config___NFQA_CFG_MAX: nfqnl_attr_config = 6;
pub type nfqnl_attr_config = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_nl {
    pub nl_family: __kernel_sa_family_t,
    pub nl_pad: ::std::os::raw::c_ushort,
    pub nl_pid: __u32,
    pub nl_groups: __u32,
}
#[test]
fn bindgen_test_layout_sockaddr_nl() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_nl>(),
        12usize,
        concat!("Size of: ", stringify!(sockaddr_nl))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_nl>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_nl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_nl>())).nl_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_nl),
            "::",
            stringify!(nl_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_nl>())).nl_pad as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_nl),
            "::",
            stringify!(nl_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_nl>())).nl_pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_nl),
            "::",
            stringify!(nl_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_nl>())).nl_groups as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_nl),
            "::",
            stringify!(nl_groups)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlmsghdr {
    pub nlmsg_len: __u32,
    pub nlmsg_type: __u16,
    pub nlmsg_flags: __u16,
    pub nlmsg_seq: __u32,
    pub nlmsg_pid: __u32,
}
#[test]
fn bindgen_test_layout_nlmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<nlmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(nlmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<nlmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(nlmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_seq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlmsgerr {
    pub error: ::std::os::raw::c_int,
    pub msg: nlmsghdr,
}
#[test]
fn bindgen_test_layout_nlmsgerr() {
    assert_eq!(
        ::std::mem::size_of::<nlmsgerr>(),
        20usize,
        concat!("Size of: ", stringify!(nlmsgerr))
    );
    assert_eq!(
        ::std::mem::align_of::<nlmsgerr>(),
        4usize,
        concat!("Alignment of ", stringify!(nlmsgerr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsgerr>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsgerr),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsgerr>())).msg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsgerr),
            "::",
            stringify!(msg)
        )
    );
}
pub const nlmsgerr_attrs_NLMSGERR_ATTR_UNUSED: nlmsgerr_attrs = 0;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MSG: nlmsgerr_attrs = 1;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_OFFS: nlmsgerr_attrs = 2;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_COOKIE: nlmsgerr_attrs = 3;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_POLICY: nlmsgerr_attrs = 4;
pub const nlmsgerr_attrs___NLMSGERR_ATTR_MAX: nlmsgerr_attrs = 5;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MAX: nlmsgerr_attrs = 4;
pub type nlmsgerr_attrs = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_pktinfo {
    pub group: __u32,
}
#[test]
fn bindgen_test_layout_nl_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<nl_pktinfo>(),
        4usize,
        concat!("Size of: ", stringify!(nl_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<nl_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(nl_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_pktinfo>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_pktinfo),
            "::",
            stringify!(group)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_mmap_req {
    pub nm_block_size: ::std::os::raw::c_uint,
    pub nm_block_nr: ::std::os::raw::c_uint,
    pub nm_frame_size: ::std::os::raw::c_uint,
    pub nm_frame_nr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nl_mmap_req() {
    assert_eq!(
        ::std::mem::size_of::<nl_mmap_req>(),
        16usize,
        concat!("Size of: ", stringify!(nl_mmap_req))
    );
    assert_eq!(
        ::std::mem::align_of::<nl_mmap_req>(),
        4usize,
        concat!("Alignment of ", stringify!(nl_mmap_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_req>())).nm_block_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_req),
            "::",
            stringify!(nm_block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_req>())).nm_block_nr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_req),
            "::",
            stringify!(nm_block_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_req>())).nm_frame_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_req),
            "::",
            stringify!(nm_frame_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_req>())).nm_frame_nr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_req),
            "::",
            stringify!(nm_frame_nr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_mmap_hdr {
    pub nm_status: ::std::os::raw::c_uint,
    pub nm_len: ::std::os::raw::c_uint,
    pub nm_group: __u32,
    pub nm_pid: __u32,
    pub nm_uid: __u32,
    pub nm_gid: __u32,
}
#[test]
fn bindgen_test_layout_nl_mmap_hdr() {
    assert_eq!(
        ::std::mem::size_of::<nl_mmap_hdr>(),
        24usize,
        concat!("Size of: ", stringify!(nl_mmap_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<nl_mmap_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(nl_mmap_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_hdr),
            "::",
            stringify!(nm_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_hdr),
            "::",
            stringify!(nm_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_hdr),
            "::",
            stringify!(nm_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_hdr),
            "::",
            stringify!(nm_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_hdr),
            "::",
            stringify!(nm_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_gid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_hdr),
            "::",
            stringify!(nm_gid)
        )
    );
}
pub const nl_mmap_status_NL_MMAP_STATUS_UNUSED: nl_mmap_status = 0;
pub const nl_mmap_status_NL_MMAP_STATUS_RESERVED: nl_mmap_status = 1;
pub const nl_mmap_status_NL_MMAP_STATUS_VALID: nl_mmap_status = 2;
pub const nl_mmap_status_NL_MMAP_STATUS_COPY: nl_mmap_status = 3;
pub const nl_mmap_status_NL_MMAP_STATUS_SKIP: nl_mmap_status = 4;
pub type nl_mmap_status = ::std::os::raw::c_uint;
pub const NETLINK_UNCONNECTED: ::std::os::raw::c_uint = 0;
pub const NETLINK_CONNECTED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlattr {
    pub nla_len: __u16,
    pub nla_type: __u16,
}
#[test]
fn bindgen_test_layout_nlattr() {
    assert_eq!(
        ::std::mem::size_of::<nlattr>(),
        4usize,
        concat!("Size of: ", stringify!(nlattr))
    );
    assert_eq!(
        ::std::mem::align_of::<nlattr>(),
        2usize,
        concat!("Alignment of ", stringify!(nlattr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlattr>())).nla_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nlattr),
            "::",
            stringify!(nla_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlattr>())).nla_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nlattr),
            "::",
            stringify!(nla_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nla_bitfield32 {
    pub value: __u32,
    pub selector: __u32,
}
#[test]
fn bindgen_test_layout_nla_bitfield32() {
    assert_eq!(
        ::std::mem::size_of::<nla_bitfield32>(),
        8usize,
        concat!("Size of: ", stringify!(nla_bitfield32))
    );
    assert_eq!(
        ::std::mem::align_of::<nla_bitfield32>(),
        4usize,
        concat!("Alignment of ", stringify!(nla_bitfield32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nla_bitfield32>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nla_bitfield32),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nla_bitfield32>())).selector as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nla_bitfield32),
            "::",
            stringify!(selector)
        )
    );
}
pub const netlink_attribute_type_NL_ATTR_TYPE_INVALID: netlink_attribute_type = 0;
pub const netlink_attribute_type_NL_ATTR_TYPE_FLAG: netlink_attribute_type = 1;
pub const netlink_attribute_type_NL_ATTR_TYPE_U8: netlink_attribute_type = 2;
pub const netlink_attribute_type_NL_ATTR_TYPE_U16: netlink_attribute_type = 3;
pub const netlink_attribute_type_NL_ATTR_TYPE_U32: netlink_attribute_type = 4;
pub const netlink_attribute_type_NL_ATTR_TYPE_U64: netlink_attribute_type = 5;
pub const netlink_attribute_type_NL_ATTR_TYPE_S8: netlink_attribute_type = 6;
pub const netlink_attribute_type_NL_ATTR_TYPE_S16: netlink_attribute_type = 7;
pub const netlink_attribute_type_NL_ATTR_TYPE_S32: netlink_attribute_type = 8;
pub const netlink_attribute_type_NL_ATTR_TYPE_S64: netlink_attribute_type = 9;
pub const netlink_attribute_type_NL_ATTR_TYPE_BINARY: netlink_attribute_type = 10;
pub const netlink_attribute_type_NL_ATTR_TYPE_STRING: netlink_attribute_type = 11;
pub const netlink_attribute_type_NL_ATTR_TYPE_NUL_STRING: netlink_attribute_type = 12;
pub const netlink_attribute_type_NL_ATTR_TYPE_NESTED: netlink_attribute_type = 13;
pub const netlink_attribute_type_NL_ATTR_TYPE_NESTED_ARRAY: netlink_attribute_type = 14;
pub const netlink_attribute_type_NL_ATTR_TYPE_BITFIELD32: netlink_attribute_type = 15;
pub type netlink_attribute_type = ::std::os::raw::c_uint;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_UNSPEC: netlink_policy_type_attr = 0;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_TYPE: netlink_policy_type_attr = 1;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MIN_VALUE_S: netlink_policy_type_attr = 2;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX_VALUE_S: netlink_policy_type_attr = 3;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MIN_VALUE_U: netlink_policy_type_attr = 4;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX_VALUE_U: netlink_policy_type_attr = 5;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MIN_LENGTH: netlink_policy_type_attr = 6;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX_LENGTH: netlink_policy_type_attr = 7;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_POLICY_IDX: netlink_policy_type_attr = 8;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE: netlink_policy_type_attr = 9;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_BITFIELD32_MASK: netlink_policy_type_attr =
    10;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_PAD: netlink_policy_type_attr = 11;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MASK: netlink_policy_type_attr = 12;
pub const netlink_policy_type_attr___NL_POLICY_TYPE_ATTR_MAX: netlink_policy_type_attr = 13;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX: netlink_policy_type_attr = 12;
pub type netlink_policy_type_attr = ::std::os::raw::c_uint;
