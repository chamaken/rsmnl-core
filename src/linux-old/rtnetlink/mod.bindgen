/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
pub type __s8 = ::std::os::raw::c_char;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
impl ::std::default::Default for __kernel_fd_set {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __kernel_sighandler_t =
    ::std::option::Option<extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
impl ::std::default::Default for __kernel_fsid_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct sysinfo {
    pub uptime: __kernel_long_t,
    pub loads: [__kernel_ulong_t; 3usize],
    pub totalram: __kernel_ulong_t,
    pub freeram: __kernel_ulong_t,
    pub sharedram: __kernel_ulong_t,
    pub bufferram: __kernel_ulong_t,
    pub totalswap: __kernel_ulong_t,
    pub freeswap: __kernel_ulong_t,
    pub procs: __u16,
    pub pad: __u16,
    pub totalhigh: __kernel_ulong_t,
    pub freehigh: __kernel_ulong_t,
    pub mem_unit: __u32,
    pub _f: [::std::os::raw::c_char; 0usize],
}
impl ::std::default::Default for sysinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __kernel_sa_family_t = ::std::os::raw::c_ushort;
pub enum sockaddr { }
#[repr(C)]
#[derive(Copy)]
pub struct __kernel_sockaddr_storage {
    pub ss_family: __kernel_sa_family_t,
    pub __data: [::std::os::raw::c_char; 126usize],
}
impl ::std::clone::Clone for __kernel_sockaddr_storage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for __kernel_sockaddr_storage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct sockaddr_nl {
    pub nl_family: __kernel_sa_family_t,
    pub nl_pad: ::std::os::raw::c_ushort,
    pub nl_pid: __u32,
    pub nl_groups: __u32,
}
impl ::std::default::Default for sockaddr_nl {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nlmsghdr {
    pub nlmsg_len: __u32,
    pub nlmsg_type: __u16,
    pub nlmsg_flags: __u16,
    pub nlmsg_seq: __u32,
    pub nlmsg_pid: __u32,
}
impl ::std::default::Default for nlmsghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nlmsgerr {
    pub error: ::std::os::raw::c_int,
    pub msg: nlmsghdr,
}
impl ::std::default::Default for nlmsgerr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nl_pktinfo {
    pub group: __u32,
}
impl ::std::default::Default for nl_pktinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nl_mmap_req {
    pub nm_block_size: ::std::os::raw::c_uint,
    pub nm_block_nr: ::std::os::raw::c_uint,
    pub nm_frame_size: ::std::os::raw::c_uint,
    pub nm_frame_nr: ::std::os::raw::c_uint,
}
impl ::std::default::Default for nl_mmap_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nl_mmap_hdr {
    pub nm_status: ::std::os::raw::c_uint,
    pub nm_len: ::std::os::raw::c_uint,
    pub nm_group: __u32,
    pub nm_pid: __u32,
    pub nm_uid: __u32,
    pub nm_gid: __u32,
}
impl ::std::default::Default for nl_mmap_hdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum nl_mmap_status {
    NL_MMAP_STATUS_UNUSED = 0,
    NL_MMAP_STATUS_RESERVED = 1,
    NL_MMAP_STATUS_VALID = 2,
    NL_MMAP_STATUS_COPY = 3,
    NL_MMAP_STATUS_SKIP = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed1 { NETLINK_UNCONNECTED = 0, NETLINK_CONNECTED = 1, }
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nlattr {
    pub nla_len: __u16,
    pub nla_type: __u16,
}
impl ::std::default::Default for nlattr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rtnl_link_stats {
    pub rx_packets: __u32,
    pub tx_packets: __u32,
    pub rx_bytes: __u32,
    pub tx_bytes: __u32,
    pub rx_errors: __u32,
    pub tx_errors: __u32,
    pub rx_dropped: __u32,
    pub tx_dropped: __u32,
    pub multicast: __u32,
    pub collisions: __u32,
    pub rx_length_errors: __u32,
    pub rx_over_errors: __u32,
    pub rx_crc_errors: __u32,
    pub rx_frame_errors: __u32,
    pub rx_fifo_errors: __u32,
    pub rx_missed_errors: __u32,
    pub tx_aborted_errors: __u32,
    pub tx_carrier_errors: __u32,
    pub tx_fifo_errors: __u32,
    pub tx_heartbeat_errors: __u32,
    pub tx_window_errors: __u32,
    pub rx_compressed: __u32,
    pub tx_compressed: __u32,
    pub rx_nohandler: __u32,
}
impl ::std::default::Default for rtnl_link_stats {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rtnl_link_stats64 {
    pub rx_packets: __u64,
    pub tx_packets: __u64,
    pub rx_bytes: __u64,
    pub tx_bytes: __u64,
    pub rx_errors: __u64,
    pub tx_errors: __u64,
    pub rx_dropped: __u64,
    pub tx_dropped: __u64,
    pub multicast: __u64,
    pub collisions: __u64,
    pub rx_length_errors: __u64,
    pub rx_over_errors: __u64,
    pub rx_crc_errors: __u64,
    pub rx_frame_errors: __u64,
    pub rx_fifo_errors: __u64,
    pub rx_missed_errors: __u64,
    pub tx_aborted_errors: __u64,
    pub tx_carrier_errors: __u64,
    pub tx_fifo_errors: __u64,
    pub tx_heartbeat_errors: __u64,
    pub tx_window_errors: __u64,
    pub rx_compressed: __u64,
    pub tx_compressed: __u64,
    pub rx_nohandler: __u64,
}
impl ::std::default::Default for rtnl_link_stats64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rtnl_link_ifmap {
    pub mem_start: __u64,
    pub mem_end: __u64,
    pub base_addr: __u64,
    pub irq: __u16,
    pub dma: __u8,
    pub port: __u8,
}
impl ::std::default::Default for rtnl_link_ifmap {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed2 {
    IFLA_UNSPEC = 0,
    IFLA_ADDRESS = 1,
    IFLA_BROADCAST = 2,
    IFLA_IFNAME = 3,
    IFLA_MTU = 4,
    IFLA_LINK = 5,
    IFLA_QDISC = 6,
    IFLA_STATS = 7,
    IFLA_COST = 8,
    IFLA_PRIORITY = 9,
    IFLA_MASTER = 10,
    IFLA_WIRELESS = 11,
    IFLA_PROTINFO = 12,
    IFLA_TXQLEN = 13,
    IFLA_MAP = 14,
    IFLA_WEIGHT = 15,
    IFLA_OPERSTATE = 16,
    IFLA_LINKMODE = 17,
    IFLA_LINKINFO = 18,
    IFLA_NET_NS_PID = 19,
    IFLA_IFALIAS = 20,
    IFLA_NUM_VF = 21,
    IFLA_VFINFO_LIST = 22,
    IFLA_STATS64 = 23,
    IFLA_VF_PORTS = 24,
    IFLA_PORT_SELF = 25,
    IFLA_AF_SPEC = 26,
    IFLA_GROUP = 27,
    IFLA_NET_NS_FD = 28,
    IFLA_EXT_MASK = 29,
    IFLA_PROMISCUITY = 30,
    IFLA_NUM_TX_QUEUES = 31,
    IFLA_NUM_RX_QUEUES = 32,
    IFLA_CARRIER = 33,
    IFLA_PHYS_PORT_ID = 34,
    IFLA_CARRIER_CHANGES = 35,
    IFLA_PHYS_SWITCH_ID = 36,
    IFLA_LINK_NETNSID = 37,
    IFLA_PHYS_PORT_NAME = 38,
    IFLA_PROTO_DOWN = 39,
    IFLA_GSO_MAX_SEGS = 40,
    IFLA_GSO_MAX_SIZE = 41,
    IFLA_PAD = 42,
    IFLA_XDP = 43,
    __IFLA_MAX = 44,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed3 {
    IFLA_INET_UNSPEC = 0,
    IFLA_INET_CONF = 1,
    __IFLA_INET_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed4 {
    IFLA_INET6_UNSPEC = 0,
    IFLA_INET6_FLAGS = 1,
    IFLA_INET6_CONF = 2,
    IFLA_INET6_STATS = 3,
    IFLA_INET6_MCAST = 4,
    IFLA_INET6_CACHEINFO = 5,
    IFLA_INET6_ICMP6STATS = 6,
    IFLA_INET6_TOKEN = 7,
    IFLA_INET6_ADDR_GEN_MODE = 8,
    __IFLA_INET6_MAX = 9,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum in6_addr_gen_mode {
    IN6_ADDR_GEN_MODE_EUI64 = 0,
    IN6_ADDR_GEN_MODE_NONE = 1,
    IN6_ADDR_GEN_MODE_STABLE_PRIVACY = 2,
    IN6_ADDR_GEN_MODE_RANDOM = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed5 {
    IFLA_BR_UNSPEC = 0,
    IFLA_BR_FORWARD_DELAY = 1,
    IFLA_BR_HELLO_TIME = 2,
    IFLA_BR_MAX_AGE = 3,
    IFLA_BR_AGEING_TIME = 4,
    IFLA_BR_STP_STATE = 5,
    IFLA_BR_PRIORITY = 6,
    IFLA_BR_VLAN_FILTERING = 7,
    IFLA_BR_VLAN_PROTOCOL = 8,
    IFLA_BR_GROUP_FWD_MASK = 9,
    IFLA_BR_ROOT_ID = 10,
    IFLA_BR_BRIDGE_ID = 11,
    IFLA_BR_ROOT_PORT = 12,
    IFLA_BR_ROOT_PATH_COST = 13,
    IFLA_BR_TOPOLOGY_CHANGE = 14,
    IFLA_BR_TOPOLOGY_CHANGE_DETECTED = 15,
    IFLA_BR_HELLO_TIMER = 16,
    IFLA_BR_TCN_TIMER = 17,
    IFLA_BR_TOPOLOGY_CHANGE_TIMER = 18,
    IFLA_BR_GC_TIMER = 19,
    IFLA_BR_GROUP_ADDR = 20,
    IFLA_BR_FDB_FLUSH = 21,
    IFLA_BR_MCAST_ROUTER = 22,
    IFLA_BR_MCAST_SNOOPING = 23,
    IFLA_BR_MCAST_QUERY_USE_IFADDR = 24,
    IFLA_BR_MCAST_QUERIER = 25,
    IFLA_BR_MCAST_HASH_ELASTICITY = 26,
    IFLA_BR_MCAST_HASH_MAX = 27,
    IFLA_BR_MCAST_LAST_MEMBER_CNT = 28,
    IFLA_BR_MCAST_STARTUP_QUERY_CNT = 29,
    IFLA_BR_MCAST_LAST_MEMBER_INTVL = 30,
    IFLA_BR_MCAST_MEMBERSHIP_INTVL = 31,
    IFLA_BR_MCAST_QUERIER_INTVL = 32,
    IFLA_BR_MCAST_QUERY_INTVL = 33,
    IFLA_BR_MCAST_QUERY_RESPONSE_INTVL = 34,
    IFLA_BR_MCAST_STARTUP_QUERY_INTVL = 35,
    IFLA_BR_NF_CALL_IPTABLES = 36,
    IFLA_BR_NF_CALL_IP6TABLES = 37,
    IFLA_BR_NF_CALL_ARPTABLES = 38,
    IFLA_BR_VLAN_DEFAULT_PVID = 39,
    IFLA_BR_PAD = 40,
    IFLA_BR_VLAN_STATS_ENABLED = 41,
    IFLA_BR_MCAST_STATS_ENABLED = 42,
    __IFLA_BR_MAX = 43,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_bridge_id {
    pub prio: [__u8; 2usize],
    pub addr: [__u8; 6usize],
}
impl ::std::default::Default for ifla_bridge_id {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed6 { BRIDGE_MODE_UNSPEC = 0, BRIDGE_MODE_HAIRPIN = 1, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed7 {
    IFLA_BRPORT_UNSPEC = 0,
    IFLA_BRPORT_STATE = 1,
    IFLA_BRPORT_PRIORITY = 2,
    IFLA_BRPORT_COST = 3,
    IFLA_BRPORT_MODE = 4,
    IFLA_BRPORT_GUARD = 5,
    IFLA_BRPORT_PROTECT = 6,
    IFLA_BRPORT_FAST_LEAVE = 7,
    IFLA_BRPORT_LEARNING = 8,
    IFLA_BRPORT_UNICAST_FLOOD = 9,
    IFLA_BRPORT_PROXYARP = 10,
    IFLA_BRPORT_LEARNING_SYNC = 11,
    IFLA_BRPORT_PROXYARP_WIFI = 12,
    IFLA_BRPORT_ROOT_ID = 13,
    IFLA_BRPORT_BRIDGE_ID = 14,
    IFLA_BRPORT_DESIGNATED_PORT = 15,
    IFLA_BRPORT_DESIGNATED_COST = 16,
    IFLA_BRPORT_ID = 17,
    IFLA_BRPORT_NO = 18,
    IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19,
    IFLA_BRPORT_CONFIG_PENDING = 20,
    IFLA_BRPORT_MESSAGE_AGE_TIMER = 21,
    IFLA_BRPORT_FORWARD_DELAY_TIMER = 22,
    IFLA_BRPORT_HOLD_TIMER = 23,
    IFLA_BRPORT_FLUSH = 24,
    IFLA_BRPORT_MULTICAST_ROUTER = 25,
    IFLA_BRPORT_PAD = 26,
    __IFLA_BRPORT_MAX = 27,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_cacheinfo {
    pub max_reasm_len: __u32,
    pub tstamp: __u32,
    pub reachable_time: __u32,
    pub retrans_time: __u32,
}
impl ::std::default::Default for ifla_cacheinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed8 {
    IFLA_INFO_UNSPEC = 0,
    IFLA_INFO_KIND = 1,
    IFLA_INFO_DATA = 2,
    IFLA_INFO_XSTATS = 3,
    IFLA_INFO_SLAVE_KIND = 4,
    IFLA_INFO_SLAVE_DATA = 5,
    __IFLA_INFO_MAX = 6,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed9 {
    IFLA_VLAN_UNSPEC = 0,
    IFLA_VLAN_ID = 1,
    IFLA_VLAN_FLAGS = 2,
    IFLA_VLAN_EGRESS_QOS = 3,
    IFLA_VLAN_INGRESS_QOS = 4,
    IFLA_VLAN_PROTOCOL = 5,
    __IFLA_VLAN_MAX = 6,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vlan_flags {
    pub flags: __u32,
    pub mask: __u32,
}
impl ::std::default::Default for ifla_vlan_flags {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed10 {
    IFLA_VLAN_QOS_UNSPEC = 0,
    IFLA_VLAN_QOS_MAPPING = 1,
    __IFLA_VLAN_QOS_MAX = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vlan_qos_mapping {
    pub from: __u32,
    pub to: __u32,
}
impl ::std::default::Default for ifla_vlan_qos_mapping {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed11 {
    IFLA_MACVLAN_UNSPEC = 0,
    IFLA_MACVLAN_MODE = 1,
    IFLA_MACVLAN_FLAGS = 2,
    IFLA_MACVLAN_MACADDR_MODE = 3,
    IFLA_MACVLAN_MACADDR = 4,
    IFLA_MACVLAN_MACADDR_DATA = 5,
    IFLA_MACVLAN_MACADDR_COUNT = 6,
    __IFLA_MACVLAN_MAX = 7,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum macvlan_mode {
    MACVLAN_MODE_PRIVATE = 1,
    MACVLAN_MODE_VEPA = 2,
    MACVLAN_MODE_BRIDGE = 4,
    MACVLAN_MODE_PASSTHRU = 8,
    MACVLAN_MODE_SOURCE = 16,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum macvlan_macaddr_mode {
    MACVLAN_MACADDR_ADD = 0,
    MACVLAN_MACADDR_DEL = 1,
    MACVLAN_MACADDR_FLUSH = 2,
    MACVLAN_MACADDR_SET = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed12 {
    IFLA_VRF_UNSPEC = 0,
    IFLA_VRF_TABLE = 1,
    __IFLA_VRF_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed13 {
    IFLA_VRF_PORT_UNSPEC = 0,
    IFLA_VRF_PORT_TABLE = 1,
    __IFLA_VRF_PORT_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed14 {
    IFLA_MACSEC_UNSPEC = 0,
    IFLA_MACSEC_SCI = 1,
    IFLA_MACSEC_PORT = 2,
    IFLA_MACSEC_ICV_LEN = 3,
    IFLA_MACSEC_CIPHER_SUITE = 4,
    IFLA_MACSEC_WINDOW = 5,
    IFLA_MACSEC_ENCODING_SA = 6,
    IFLA_MACSEC_ENCRYPT = 7,
    IFLA_MACSEC_PROTECT = 8,
    IFLA_MACSEC_INC_SCI = 9,
    IFLA_MACSEC_ES = 10,
    IFLA_MACSEC_SCB = 11,
    IFLA_MACSEC_REPLAY_PROTECT = 12,
    IFLA_MACSEC_VALIDATION = 13,
    IFLA_MACSEC_PAD = 14,
    __IFLA_MACSEC_MAX = 15,
}
pub const MACSEC_VALIDATE_MAX: macsec_validation_type =
    macsec_validation_type::MACSEC_VALIDATE_STRICT;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum macsec_validation_type {
    MACSEC_VALIDATE_DISABLED = 0,
    MACSEC_VALIDATE_CHECK = 1,
    MACSEC_VALIDATE_STRICT = 2,
    __MACSEC_VALIDATE_END = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed15 {
    IFLA_IPVLAN_UNSPEC = 0,
    IFLA_IPVLAN_MODE = 1,
    __IFLA_IPVLAN_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum ipvlan_mode {
    IPVLAN_MODE_L2 = 0,
    IPVLAN_MODE_L3 = 1,
    IPVLAN_MODE_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed16 {
    IFLA_VXLAN_UNSPEC = 0,
    IFLA_VXLAN_ID = 1,
    IFLA_VXLAN_GROUP = 2,
    IFLA_VXLAN_LINK = 3,
    IFLA_VXLAN_LOCAL = 4,
    IFLA_VXLAN_TTL = 5,
    IFLA_VXLAN_TOS = 6,
    IFLA_VXLAN_LEARNING = 7,
    IFLA_VXLAN_AGEING = 8,
    IFLA_VXLAN_LIMIT = 9,
    IFLA_VXLAN_PORT_RANGE = 10,
    IFLA_VXLAN_PROXY = 11,
    IFLA_VXLAN_RSC = 12,
    IFLA_VXLAN_L2MISS = 13,
    IFLA_VXLAN_L3MISS = 14,
    IFLA_VXLAN_PORT = 15,
    IFLA_VXLAN_GROUP6 = 16,
    IFLA_VXLAN_LOCAL6 = 17,
    IFLA_VXLAN_UDP_CSUM = 18,
    IFLA_VXLAN_UDP_ZERO_CSUM6_TX = 19,
    IFLA_VXLAN_UDP_ZERO_CSUM6_RX = 20,
    IFLA_VXLAN_REMCSUM_TX = 21,
    IFLA_VXLAN_REMCSUM_RX = 22,
    IFLA_VXLAN_GBP = 23,
    IFLA_VXLAN_REMCSUM_NOPARTIAL = 24,
    IFLA_VXLAN_COLLECT_METADATA = 25,
    IFLA_VXLAN_LABEL = 26,
    IFLA_VXLAN_GPE = 27,
    __IFLA_VXLAN_MAX = 28,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vxlan_port_range {
    pub low: __be16,
    pub high: __be16,
}
impl ::std::default::Default for ifla_vxlan_port_range {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed17 {
    IFLA_GENEVE_UNSPEC = 0,
    IFLA_GENEVE_ID = 1,
    IFLA_GENEVE_REMOTE = 2,
    IFLA_GENEVE_TTL = 3,
    IFLA_GENEVE_TOS = 4,
    IFLA_GENEVE_PORT = 5,
    IFLA_GENEVE_COLLECT_METADATA = 6,
    IFLA_GENEVE_REMOTE6 = 7,
    IFLA_GENEVE_UDP_CSUM = 8,
    IFLA_GENEVE_UDP_ZERO_CSUM6_TX = 9,
    IFLA_GENEVE_UDP_ZERO_CSUM6_RX = 10,
    IFLA_GENEVE_LABEL = 11,
    __IFLA_GENEVE_MAX = 12,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed18 {
    IFLA_PPP_UNSPEC = 0,
    IFLA_PPP_DEV_FD = 1,
    __IFLA_PPP_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed19 {
    IFLA_GTP_UNSPEC = 0,
    IFLA_GTP_FD0 = 1,
    IFLA_GTP_FD1 = 2,
    IFLA_GTP_PDP_HASHSIZE = 3,
    __IFLA_GTP_MAX = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed20 {
    IFLA_BOND_UNSPEC = 0,
    IFLA_BOND_MODE = 1,
    IFLA_BOND_ACTIVE_SLAVE = 2,
    IFLA_BOND_MIIMON = 3,
    IFLA_BOND_UPDELAY = 4,
    IFLA_BOND_DOWNDELAY = 5,
    IFLA_BOND_USE_CARRIER = 6,
    IFLA_BOND_ARP_INTERVAL = 7,
    IFLA_BOND_ARP_IP_TARGET = 8,
    IFLA_BOND_ARP_VALIDATE = 9,
    IFLA_BOND_ARP_ALL_TARGETS = 10,
    IFLA_BOND_PRIMARY = 11,
    IFLA_BOND_PRIMARY_RESELECT = 12,
    IFLA_BOND_FAIL_OVER_MAC = 13,
    IFLA_BOND_XMIT_HASH_POLICY = 14,
    IFLA_BOND_RESEND_IGMP = 15,
    IFLA_BOND_NUM_PEER_NOTIF = 16,
    IFLA_BOND_ALL_SLAVES_ACTIVE = 17,
    IFLA_BOND_MIN_LINKS = 18,
    IFLA_BOND_LP_INTERVAL = 19,
    IFLA_BOND_PACKETS_PER_SLAVE = 20,
    IFLA_BOND_AD_LACP_RATE = 21,
    IFLA_BOND_AD_SELECT = 22,
    IFLA_BOND_AD_INFO = 23,
    IFLA_BOND_AD_ACTOR_SYS_PRIO = 24,
    IFLA_BOND_AD_USER_PORT_KEY = 25,
    IFLA_BOND_AD_ACTOR_SYSTEM = 26,
    IFLA_BOND_TLB_DYNAMIC_LB = 27,
    __IFLA_BOND_MAX = 28,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed21 {
    IFLA_BOND_AD_INFO_UNSPEC = 0,
    IFLA_BOND_AD_INFO_AGGREGATOR = 1,
    IFLA_BOND_AD_INFO_NUM_PORTS = 2,
    IFLA_BOND_AD_INFO_ACTOR_KEY = 3,
    IFLA_BOND_AD_INFO_PARTNER_KEY = 4,
    IFLA_BOND_AD_INFO_PARTNER_MAC = 5,
    __IFLA_BOND_AD_INFO_MAX = 6,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed22 {
    IFLA_BOND_SLAVE_UNSPEC = 0,
    IFLA_BOND_SLAVE_STATE = 1,
    IFLA_BOND_SLAVE_MII_STATUS = 2,
    IFLA_BOND_SLAVE_LINK_FAILURE_COUNT = 3,
    IFLA_BOND_SLAVE_PERM_HWADDR = 4,
    IFLA_BOND_SLAVE_QUEUE_ID = 5,
    IFLA_BOND_SLAVE_AD_AGGREGATOR_ID = 6,
    IFLA_BOND_SLAVE_AD_ACTOR_OPER_PORT_STATE = 7,
    IFLA_BOND_SLAVE_AD_PARTNER_OPER_PORT_STATE = 8,
    __IFLA_BOND_SLAVE_MAX = 9,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed23 {
    IFLA_VF_INFO_UNSPEC = 0,
    IFLA_VF_INFO = 1,
    __IFLA_VF_INFO_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed24 {
    IFLA_VF_UNSPEC = 0,
    IFLA_VF_MAC = 1,
    IFLA_VF_VLAN = 2,
    IFLA_VF_TX_RATE = 3,
    IFLA_VF_SPOOFCHK = 4,
    IFLA_VF_LINK_STATE = 5,
    IFLA_VF_RATE = 6,
    IFLA_VF_RSS_QUERY_EN = 7,
    IFLA_VF_STATS = 8,
    IFLA_VF_TRUST = 9,
    IFLA_VF_IB_NODE_GUID = 10,
    IFLA_VF_IB_PORT_GUID = 11,
    __IFLA_VF_MAX = 12,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_mac {
    pub vf: __u32,
    pub mac: [__u8; 32usize],
}
impl ::std::default::Default for ifla_vf_mac {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_vlan {
    pub vf: __u32,
    pub vlan: __u32,
    pub qos: __u32,
}
impl ::std::default::Default for ifla_vf_vlan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_tx_rate {
    pub vf: __u32,
    pub rate: __u32,
}
impl ::std::default::Default for ifla_vf_tx_rate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_rate {
    pub vf: __u32,
    pub min_tx_rate: __u32,
    pub max_tx_rate: __u32,
}
impl ::std::default::Default for ifla_vf_rate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_spoofchk {
    pub vf: __u32,
    pub setting: __u32,
}
impl ::std::default::Default for ifla_vf_spoofchk {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_guid {
    pub vf: __u32,
    pub guid: __u64,
}
impl ::std::default::Default for ifla_vf_guid {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed25 {
    IFLA_VF_LINK_STATE_AUTO = 0,
    IFLA_VF_LINK_STATE_ENABLE = 1,
    IFLA_VF_LINK_STATE_DISABLE = 2,
    __IFLA_VF_LINK_STATE_MAX = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_link_state {
    pub vf: __u32,
    pub link_state: __u32,
}
impl ::std::default::Default for ifla_vf_link_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_rss_query_en {
    pub vf: __u32,
    pub setting: __u32,
}
impl ::std::default::Default for ifla_vf_rss_query_en {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed26 {
    IFLA_VF_STATS_RX_PACKETS = 0,
    IFLA_VF_STATS_TX_PACKETS = 1,
    IFLA_VF_STATS_RX_BYTES = 2,
    IFLA_VF_STATS_TX_BYTES = 3,
    IFLA_VF_STATS_BROADCAST = 4,
    IFLA_VF_STATS_MULTICAST = 5,
    IFLA_VF_STATS_PAD = 6,
    __IFLA_VF_STATS_MAX = 7,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_trust {
    pub vf: __u32,
    pub setting: __u32,
}
impl ::std::default::Default for ifla_vf_trust {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed27 {
    IFLA_VF_PORT_UNSPEC = 0,
    IFLA_VF_PORT = 1,
    __IFLA_VF_PORT_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed28 {
    IFLA_PORT_UNSPEC = 0,
    IFLA_PORT_VF = 1,
    IFLA_PORT_PROFILE = 2,
    IFLA_PORT_VSI_TYPE = 3,
    IFLA_PORT_INSTANCE_UUID = 4,
    IFLA_PORT_HOST_UUID = 5,
    IFLA_PORT_REQUEST = 6,
    IFLA_PORT_RESPONSE = 7,
    __IFLA_PORT_MAX = 8,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed29 {
    PORT_REQUEST_PREASSOCIATE = 0,
    PORT_REQUEST_PREASSOCIATE_RR = 1,
    PORT_REQUEST_ASSOCIATE = 2,
    PORT_REQUEST_DISASSOCIATE = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed30 {
    PORT_VDP_RESPONSE_SUCCESS = 0,
    PORT_VDP_RESPONSE_INVALID_FORMAT = 1,
    PORT_VDP_RESPONSE_INSUFFICIENT_RESOURCES = 2,
    PORT_VDP_RESPONSE_UNUSED_VTID = 3,
    PORT_VDP_RESPONSE_VTID_VIOLATION = 4,
    PORT_VDP_RESPONSE_VTID_VERSION_VIOALTION = 5,
    PORT_VDP_RESPONSE_OUT_OF_SYNC = 6,
    PORT_PROFILE_RESPONSE_SUCCESS = 256,
    PORT_PROFILE_RESPONSE_INPROGRESS = 257,
    PORT_PROFILE_RESPONSE_INVALID = 258,
    PORT_PROFILE_RESPONSE_BADSTATE = 259,
    PORT_PROFILE_RESPONSE_INSUFFICIENT_RESOURCES = 260,
    PORT_PROFILE_RESPONSE_ERROR = 261,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_port_vsi {
    pub vsi_mgr_id: __u8,
    pub vsi_type_id: [__u8; 3usize],
    pub vsi_type_version: __u8,
    pub pad: [__u8; 3usize],
}
impl ::std::default::Default for ifla_port_vsi {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed31 {
    IFLA_IPOIB_UNSPEC = 0,
    IFLA_IPOIB_PKEY = 1,
    IFLA_IPOIB_MODE = 2,
    IFLA_IPOIB_UMCAST = 3,
    __IFLA_IPOIB_MAX = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed32 { IPOIB_MODE_DATAGRAM = 0, IPOIB_MODE_CONNECTED = 1, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed33 {
    IFLA_HSR_UNSPEC = 0,
    IFLA_HSR_SLAVE1 = 1,
    IFLA_HSR_SLAVE2 = 2,
    IFLA_HSR_MULTICAST_SPEC = 3,
    IFLA_HSR_SUPERVISION_ADDR = 4,
    IFLA_HSR_SEQ_NR = 5,
    IFLA_HSR_VERSION = 6,
    __IFLA_HSR_MAX = 7,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct if_stats_msg {
    pub family: __u8,
    pub pad1: __u8,
    pub pad2: __u16,
    pub ifindex: __u32,
    pub filter_mask: __u32,
}
impl ::std::default::Default for if_stats_msg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed34 {
    IFLA_STATS_UNSPEC = 0,
    IFLA_STATS_LINK_64 = 1,
    IFLA_STATS_LINK_XSTATS = 2,
    IFLA_STATS_LINK_XSTATS_SLAVE = 3,
    __IFLA_STATS_MAX = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed35 {
    LINK_XSTATS_TYPE_UNSPEC = 0,
    LINK_XSTATS_TYPE_BRIDGE = 1,
    __LINK_XSTATS_TYPE_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed36 {
    IFLA_XDP_UNSPEC = 0,
    IFLA_XDP_FD = 1,
    IFLA_XDP_ATTACHED = 2,
    __IFLA_XDP_MAX = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifaddrmsg {
    pub ifa_family: __u8,
    pub ifa_prefixlen: __u8,
    pub ifa_flags: __u8,
    pub ifa_scope: __u8,
    pub ifa_index: __u32,
}
impl ::std::default::Default for ifaddrmsg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed37 {
    IFA_UNSPEC = 0,
    IFA_ADDRESS = 1,
    IFA_LOCAL = 2,
    IFA_LABEL = 3,
    IFA_BROADCAST = 4,
    IFA_ANYCAST = 5,
    IFA_CACHEINFO = 6,
    IFA_MULTICAST = 7,
    IFA_FLAGS = 8,
    __IFA_MAX = 9,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifa_cacheinfo {
    pub ifa_prefered: __u32,
    pub ifa_valid: __u32,
    pub cstamp: __u32,
    pub tstamp: __u32,
}
impl ::std::default::Default for ifa_cacheinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ndmsg {
    pub ndm_family: __u8,
    pub ndm_pad1: __u8,
    pub ndm_pad2: __u16,
    pub ndm_ifindex: __s32,
    pub ndm_state: __u16,
    pub ndm_flags: __u8,
    pub ndm_type: __u8,
}
impl ::std::default::Default for ndmsg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed38 {
    NDA_UNSPEC = 0,
    NDA_DST = 1,
    NDA_LLADDR = 2,
    NDA_CACHEINFO = 3,
    NDA_PROBES = 4,
    NDA_VLAN = 5,
    NDA_PORT = 6,
    NDA_VNI = 7,
    NDA_IFINDEX = 8,
    NDA_MASTER = 9,
    NDA_LINK_NETNSID = 10,
    __NDA_MAX = 11,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nda_cacheinfo {
    pub ndm_confirmed: __u32,
    pub ndm_used: __u32,
    pub ndm_updated: __u32,
    pub ndm_refcnt: __u32,
}
impl ::std::default::Default for nda_cacheinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ndt_stats {
    pub ndts_allocs: __u64,
    pub ndts_destroys: __u64,
    pub ndts_hash_grows: __u64,
    pub ndts_res_failed: __u64,
    pub ndts_lookups: __u64,
    pub ndts_hits: __u64,
    pub ndts_rcv_probes_mcast: __u64,
    pub ndts_rcv_probes_ucast: __u64,
    pub ndts_periodic_gc_runs: __u64,
    pub ndts_forced_gc_runs: __u64,
    pub ndts_table_fulls: __u64,
}
impl ::std::default::Default for ndt_stats {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed39 {
    NDTPA_UNSPEC = 0,
    NDTPA_IFINDEX = 1,
    NDTPA_REFCNT = 2,
    NDTPA_REACHABLE_TIME = 3,
    NDTPA_BASE_REACHABLE_TIME = 4,
    NDTPA_RETRANS_TIME = 5,
    NDTPA_GC_STALETIME = 6,
    NDTPA_DELAY_PROBE_TIME = 7,
    NDTPA_QUEUE_LEN = 8,
    NDTPA_APP_PROBES = 9,
    NDTPA_UCAST_PROBES = 10,
    NDTPA_MCAST_PROBES = 11,
    NDTPA_ANYCAST_DELAY = 12,
    NDTPA_PROXY_DELAY = 13,
    NDTPA_PROXY_QLEN = 14,
    NDTPA_LOCKTIME = 15,
    NDTPA_QUEUE_LENBYTES = 16,
    NDTPA_MCAST_REPROBES = 17,
    NDTPA_PAD = 18,
    __NDTPA_MAX = 19,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ndtmsg {
    pub ndtm_family: __u8,
    pub ndtm_pad1: __u8,
    pub ndtm_pad2: __u16,
}
impl ::std::default::Default for ndtmsg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ndt_config {
    pub ndtc_key_len: __u16,
    pub ndtc_entry_size: __u16,
    pub ndtc_entries: __u32,
    pub ndtc_last_flush: __u32,
    pub ndtc_last_rand: __u32,
    pub ndtc_hash_rnd: __u32,
    pub ndtc_hash_mask: __u32,
    pub ndtc_hash_chain_gc: __u32,
    pub ndtc_proxy_qlen: __u32,
}
impl ::std::default::Default for ndt_config {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed40 {
    NDTA_UNSPEC = 0,
    NDTA_NAME = 1,
    NDTA_THRESH1 = 2,
    NDTA_THRESH2 = 3,
    NDTA_THRESH3 = 4,
    NDTA_CONFIG = 5,
    NDTA_PARMS = 6,
    NDTA_STATS = 7,
    NDTA_GC_INTERVAL = 8,
    NDTA_PAD = 9,
    __NDTA_MAX = 10,
}
pub const RTM_NEWLINK: Enum_Unnamed41 = Enum_Unnamed41::RTM_BASE;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed41 {
    RTM_BASE = 16,
    RTM_DELLINK = 17,
    RTM_GETLINK = 18,
    RTM_SETLINK = 19,
    RTM_NEWADDR = 20,
    RTM_DELADDR = 21,
    RTM_GETADDR = 22,
    RTM_NEWROUTE = 24,
    RTM_DELROUTE = 25,
    RTM_GETROUTE = 26,
    RTM_NEWNEIGH = 28,
    RTM_DELNEIGH = 29,
    RTM_GETNEIGH = 30,
    RTM_NEWRULE = 32,
    RTM_DELRULE = 33,
    RTM_GETRULE = 34,
    RTM_NEWQDISC = 36,
    RTM_DELQDISC = 37,
    RTM_GETQDISC = 38,
    RTM_NEWTCLASS = 40,
    RTM_DELTCLASS = 41,
    RTM_GETTCLASS = 42,
    RTM_NEWTFILTER = 44,
    RTM_DELTFILTER = 45,
    RTM_GETTFILTER = 46,
    RTM_NEWACTION = 48,
    RTM_DELACTION = 49,
    RTM_GETACTION = 50,
    RTM_NEWPREFIX = 52,
    RTM_GETMULTICAST = 58,
    RTM_GETANYCAST = 62,
    RTM_NEWNEIGHTBL = 64,
    RTM_GETNEIGHTBL = 66,
    RTM_SETNEIGHTBL = 67,
    RTM_NEWNDUSEROPT = 68,
    RTM_NEWADDRLABEL = 72,
    RTM_DELADDRLABEL = 73,
    RTM_GETADDRLABEL = 74,
    RTM_GETDCB = 78,
    RTM_SETDCB = 79,
    RTM_NEWNETCONF = 80,
    RTM_GETNETCONF = 82,
    RTM_NEWMDB = 84,
    RTM_DELMDB = 85,
    RTM_GETMDB = 86,
    RTM_NEWNSID = 88,
    RTM_DELNSID = 89,
    RTM_GETNSID = 90,
    RTM_NEWSTATS = 92,
    RTM_GETSTATS = 94,
    __RTM_MAX = 95,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rtattr {
    pub rta_len: ::std::os::raw::c_ushort,
    pub rta_type: ::std::os::raw::c_ushort,
}
impl ::std::default::Default for rtattr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rtmsg {
    pub rtm_family: ::std::os::raw::c_uchar,
    pub rtm_dst_len: ::std::os::raw::c_uchar,
    pub rtm_src_len: ::std::os::raw::c_uchar,
    pub rtm_tos: ::std::os::raw::c_uchar,
    pub rtm_table: ::std::os::raw::c_uchar,
    pub rtm_protocol: ::std::os::raw::c_uchar,
    pub rtm_scope: ::std::os::raw::c_uchar,
    pub rtm_type: ::std::os::raw::c_uchar,
    pub rtm_flags: ::std::os::raw::c_uint,
}
impl ::std::default::Default for rtmsg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed42 {
    RTN_UNSPEC = 0,
    RTN_UNICAST = 1,
    RTN_LOCAL = 2,
    RTN_BROADCAST = 3,
    RTN_ANYCAST = 4,
    RTN_MULTICAST = 5,
    RTN_BLACKHOLE = 6,
    RTN_UNREACHABLE = 7,
    RTN_PROHIBIT = 8,
    RTN_THROW = 9,
    RTN_NAT = 10,
    RTN_XRESOLVE = 11,
    __RTN_MAX = 12,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum rt_scope_t {
    RT_SCOPE_UNIVERSE = 0,
    RT_SCOPE_SITE = 200,
    RT_SCOPE_LINK = 253,
    RT_SCOPE_HOST = 254,
    RT_SCOPE_NOWHERE = 255,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum rt_class_t {
    RT_TABLE_UNSPEC = 0,
    RT_TABLE_COMPAT = 252,
    RT_TABLE_DEFAULT = 253,
    RT_TABLE_MAIN = 254,
    RT_TABLE_LOCAL = 255,
    RT_TABLE_MAX = 4294967295,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum rtattr_type_t {
    RTA_UNSPEC = 0,
    RTA_DST = 1,
    RTA_SRC = 2,
    RTA_IIF = 3,
    RTA_OIF = 4,
    RTA_GATEWAY = 5,
    RTA_PRIORITY = 6,
    RTA_PREFSRC = 7,
    RTA_METRICS = 8,
    RTA_MULTIPATH = 9,
    RTA_PROTOINFO = 10,
    RTA_FLOW = 11,
    RTA_CACHEINFO = 12,
    RTA_SESSION = 13,
    RTA_MP_ALGO = 14,
    RTA_TABLE = 15,
    RTA_MARK = 16,
    RTA_MFC_STATS = 17,
    RTA_VIA = 18,
    RTA_NEWDST = 19,
    RTA_PREF = 20,
    RTA_ENCAP_TYPE = 21,
    RTA_ENCAP = 22,
    RTA_EXPIRES = 23,
    RTA_PAD = 24,
    RTA_UID = 25,
    __RTA_MAX = 26,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rtnexthop {
    pub rtnh_len: ::std::os::raw::c_ushort,
    pub rtnh_flags: ::std::os::raw::c_uchar,
    pub rtnh_hops: ::std::os::raw::c_uchar,
    pub rtnh_ifindex: ::std::os::raw::c_int,
}
impl ::std::default::Default for rtnexthop {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rtvia {
    pub rtvia_family: __kernel_sa_family_t,
    pub rtvia_addr: [__u8; 0usize],
}
impl ::std::default::Default for rtvia {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rta_cacheinfo {
    pub rta_clntref: __u32,
    pub rta_lastuse: __u32,
    pub rta_expires: __s32,
    pub rta_error: __u32,
    pub rta_used: __u32,
    pub rta_id: __u32,
    pub rta_ts: __u32,
    pub rta_tsage: __u32,
}
impl ::std::default::Default for rta_cacheinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed43 {
    RTAX_UNSPEC = 0,
    RTAX_LOCK = 1,
    RTAX_MTU = 2,
    RTAX_WINDOW = 3,
    RTAX_RTT = 4,
    RTAX_RTTVAR = 5,
    RTAX_SSTHRESH = 6,
    RTAX_CWND = 7,
    RTAX_ADVMSS = 8,
    RTAX_REORDERING = 9,
    RTAX_HOPLIMIT = 10,
    RTAX_INITCWND = 11,
    RTAX_FEATURES = 12,
    RTAX_RTO_MIN = 13,
    RTAX_INITRWND = 14,
    RTAX_QUICKACK = 15,
    RTAX_CC_ALGO = 16,
    __RTAX_MAX = 17,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rta_session {
    pub proto: __u8,
    pub pad1: __u8,
    pub pad2: __u16,
    pub u: Union_Unnamed44,
}
impl ::std::default::Default for rta_session {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Union_Unnamed44 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed44 {
    pub unsafe fn ports(&mut self) -> *mut Struct_Unnamed45 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn icmpt(&mut self) -> *mut Struct_Unnamed46 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn spi(&mut self) -> *mut __u32 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for Union_Unnamed44 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Struct_Unnamed45 {
    pub sport: __u16,
    pub dport: __u16,
}
impl ::std::default::Default for Struct_Unnamed45 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Struct_Unnamed46 {
    pub type_: __u8,
    pub code: __u8,
    pub ident: __u16,
}
impl ::std::default::Default for Struct_Unnamed46 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rta_mfc_stats {
    pub mfcs_packets: __u64,
    pub mfcs_bytes: __u64,
    pub mfcs_wrong_if: __u64,
}
impl ::std::default::Default for rta_mfc_stats {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rtgenmsg {
    pub rtgen_family: ::std::os::raw::c_uchar,
}
impl ::std::default::Default for rtgenmsg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifinfomsg {
    pub ifi_family: ::std::os::raw::c_uchar,
    pub __ifi_pad: ::std::os::raw::c_uchar,
    pub ifi_type: ::std::os::raw::c_ushort,
    pub ifi_index: ::std::os::raw::c_int,
    pub ifi_flags: ::std::os::raw::c_uint,
    pub ifi_change: ::std::os::raw::c_uint,
}
impl ::std::default::Default for ifinfomsg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct prefixmsg {
    pub prefix_family: ::std::os::raw::c_uchar,
    pub prefix_pad1: ::std::os::raw::c_uchar,
    pub prefix_pad2: ::std::os::raw::c_ushort,
    pub prefix_ifindex: ::std::os::raw::c_int,
    pub prefix_type: ::std::os::raw::c_uchar,
    pub prefix_len: ::std::os::raw::c_uchar,
    pub prefix_flags: ::std::os::raw::c_uchar,
    pub prefix_pad3: ::std::os::raw::c_uchar,
}
impl ::std::default::Default for prefixmsg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed47 {
    PREFIX_UNSPEC = 0,
    PREFIX_ADDRESS = 1,
    PREFIX_CACHEINFO = 2,
    __PREFIX_MAX = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct prefix_cacheinfo {
    pub preferred_time: __u32,
    pub valid_time: __u32,
}
impl ::std::default::Default for prefix_cacheinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct tcmsg {
    pub tcm_family: ::std::os::raw::c_uchar,
    pub tcm__pad1: ::std::os::raw::c_uchar,
    pub tcm__pad2: ::std::os::raw::c_ushort,
    pub tcm_ifindex: ::std::os::raw::c_int,
    pub tcm_handle: __u32,
    pub tcm_parent: __u32,
    pub tcm_info: __u32,
}
impl ::std::default::Default for tcmsg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed48 {
    TCA_UNSPEC = 0,
    TCA_KIND = 1,
    TCA_OPTIONS = 2,
    TCA_STATS = 3,
    TCA_XSTATS = 4,
    TCA_RATE = 5,
    TCA_FCNT = 6,
    TCA_STATS2 = 7,
    TCA_STAB = 8,
    TCA_PAD = 9,
    __TCA_MAX = 10,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nduseroptmsg {
    pub nduseropt_family: ::std::os::raw::c_uchar,
    pub nduseropt_pad1: ::std::os::raw::c_uchar,
    pub nduseropt_opts_len: ::std::os::raw::c_ushort,
    pub nduseropt_ifindex: ::std::os::raw::c_int,
    pub nduseropt_icmp_type: __u8,
    pub nduseropt_icmp_code: __u8,
    pub nduseropt_pad2: ::std::os::raw::c_ushort,
    pub nduseropt_pad3: ::std::os::raw::c_uint,
}
impl ::std::default::Default for nduseroptmsg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed49 {
    NDUSEROPT_UNSPEC = 0,
    NDUSEROPT_SRCADDR = 1,
    __NDUSEROPT_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum rtnetlink_groups {
    RTNLGRP_NONE = 0,
    RTNLGRP_LINK = 1,
    RTNLGRP_NOTIFY = 2,
    RTNLGRP_NEIGH = 3,
    RTNLGRP_TC = 4,
    RTNLGRP_IPV4_IFADDR = 5,
    RTNLGRP_IPV4_MROUTE = 6,
    RTNLGRP_IPV4_ROUTE = 7,
    RTNLGRP_IPV4_RULE = 8,
    RTNLGRP_IPV6_IFADDR = 9,
    RTNLGRP_IPV6_MROUTE = 10,
    RTNLGRP_IPV6_ROUTE = 11,
    RTNLGRP_IPV6_IFINFO = 12,
    RTNLGRP_DECnet_IFADDR = 13,
    RTNLGRP_NOP2 = 14,
    RTNLGRP_DECnet_ROUTE = 15,
    RTNLGRP_DECnet_RULE = 16,
    RTNLGRP_NOP4 = 17,
    RTNLGRP_IPV6_PREFIX = 18,
    RTNLGRP_IPV6_RULE = 19,
    RTNLGRP_ND_USEROPT = 20,
    RTNLGRP_PHONET_IFADDR = 21,
    RTNLGRP_PHONET_ROUTE = 22,
    RTNLGRP_DCB = 23,
    RTNLGRP_IPV4_NETCONF = 24,
    RTNLGRP_IPV6_NETCONF = 25,
    RTNLGRP_MDB = 26,
    RTNLGRP_MPLS_ROUTE = 27,
    RTNLGRP_NSID = 28,
    __RTNLGRP_MAX = 29,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct tcamsg {
    pub tca_family: ::std::os::raw::c_uchar,
    pub tca__pad1: ::std::os::raw::c_uchar,
    pub tca__pad2: ::std::os::raw::c_ushort,
}
impl ::std::default::Default for tcamsg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
