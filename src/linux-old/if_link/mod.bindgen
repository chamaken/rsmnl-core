/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
pub type __s8 = ::std::os::raw::c_char;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
impl ::std::default::Default for __kernel_fd_set {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __kernel_sighandler_t =
    ::std::option::Option<extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
impl ::std::default::Default for __kernel_fsid_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct sysinfo {
    pub uptime: __kernel_long_t,
    pub loads: [__kernel_ulong_t; 3usize],
    pub totalram: __kernel_ulong_t,
    pub freeram: __kernel_ulong_t,
    pub sharedram: __kernel_ulong_t,
    pub bufferram: __kernel_ulong_t,
    pub totalswap: __kernel_ulong_t,
    pub freeswap: __kernel_ulong_t,
    pub procs: __u16,
    pub pad: __u16,
    pub totalhigh: __kernel_ulong_t,
    pub freehigh: __kernel_ulong_t,
    pub mem_unit: __u32,
    pub _f: [::std::os::raw::c_char; 0usize],
}
impl ::std::default::Default for sysinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __kernel_sa_family_t = ::std::os::raw::c_ushort;
pub enum sockaddr { }
#[repr(C)]
#[derive(Copy)]
pub struct __kernel_sockaddr_storage {
    pub ss_family: __kernel_sa_family_t,
    pub __data: [::std::os::raw::c_char; 126usize],
}
impl ::std::clone::Clone for __kernel_sockaddr_storage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for __kernel_sockaddr_storage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct sockaddr_nl {
    pub nl_family: __kernel_sa_family_t,
    pub nl_pad: ::std::os::raw::c_ushort,
    pub nl_pid: __u32,
    pub nl_groups: __u32,
}
impl ::std::default::Default for sockaddr_nl {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nlmsghdr {
    pub nlmsg_len: __u32,
    pub nlmsg_type: __u16,
    pub nlmsg_flags: __u16,
    pub nlmsg_seq: __u32,
    pub nlmsg_pid: __u32,
}
impl ::std::default::Default for nlmsghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nlmsgerr {
    pub error: ::std::os::raw::c_int,
    pub msg: nlmsghdr,
}
impl ::std::default::Default for nlmsgerr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nl_pktinfo {
    pub group: __u32,
}
impl ::std::default::Default for nl_pktinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nl_mmap_req {
    pub nm_block_size: ::std::os::raw::c_uint,
    pub nm_block_nr: ::std::os::raw::c_uint,
    pub nm_frame_size: ::std::os::raw::c_uint,
    pub nm_frame_nr: ::std::os::raw::c_uint,
}
impl ::std::default::Default for nl_mmap_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nl_mmap_hdr {
    pub nm_status: ::std::os::raw::c_uint,
    pub nm_len: ::std::os::raw::c_uint,
    pub nm_group: __u32,
    pub nm_pid: __u32,
    pub nm_uid: __u32,
    pub nm_gid: __u32,
}
impl ::std::default::Default for nl_mmap_hdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum nl_mmap_status {
    NL_MMAP_STATUS_UNUSED = 0,
    NL_MMAP_STATUS_RESERVED = 1,
    NL_MMAP_STATUS_VALID = 2,
    NL_MMAP_STATUS_COPY = 3,
    NL_MMAP_STATUS_SKIP = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed1 { NETLINK_UNCONNECTED = 0, NETLINK_CONNECTED = 1, }
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nlattr {
    pub nla_len: __u16,
    pub nla_type: __u16,
}
impl ::std::default::Default for nlattr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rtnl_link_stats {
    pub rx_packets: __u32,
    pub tx_packets: __u32,
    pub rx_bytes: __u32,
    pub tx_bytes: __u32,
    pub rx_errors: __u32,
    pub tx_errors: __u32,
    pub rx_dropped: __u32,
    pub tx_dropped: __u32,
    pub multicast: __u32,
    pub collisions: __u32,
    pub rx_length_errors: __u32,
    pub rx_over_errors: __u32,
    pub rx_crc_errors: __u32,
    pub rx_frame_errors: __u32,
    pub rx_fifo_errors: __u32,
    pub rx_missed_errors: __u32,
    pub tx_aborted_errors: __u32,
    pub tx_carrier_errors: __u32,
    pub tx_fifo_errors: __u32,
    pub tx_heartbeat_errors: __u32,
    pub tx_window_errors: __u32,
    pub rx_compressed: __u32,
    pub tx_compressed: __u32,
    pub rx_nohandler: __u32,
}
impl ::std::default::Default for rtnl_link_stats {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rtnl_link_stats64 {
    pub rx_packets: __u64,
    pub tx_packets: __u64,
    pub rx_bytes: __u64,
    pub tx_bytes: __u64,
    pub rx_errors: __u64,
    pub tx_errors: __u64,
    pub rx_dropped: __u64,
    pub tx_dropped: __u64,
    pub multicast: __u64,
    pub collisions: __u64,
    pub rx_length_errors: __u64,
    pub rx_over_errors: __u64,
    pub rx_crc_errors: __u64,
    pub rx_frame_errors: __u64,
    pub rx_fifo_errors: __u64,
    pub rx_missed_errors: __u64,
    pub tx_aborted_errors: __u64,
    pub tx_carrier_errors: __u64,
    pub tx_fifo_errors: __u64,
    pub tx_heartbeat_errors: __u64,
    pub tx_window_errors: __u64,
    pub rx_compressed: __u64,
    pub tx_compressed: __u64,
    pub rx_nohandler: __u64,
}
impl ::std::default::Default for rtnl_link_stats64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct rtnl_link_ifmap {
    pub mem_start: __u64,
    pub mem_end: __u64,
    pub base_addr: __u64,
    pub irq: __u16,
    pub dma: __u8,
    pub port: __u8,
}
impl ::std::default::Default for rtnl_link_ifmap {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed2 {
    IFLA_UNSPEC = 0,
    IFLA_ADDRESS = 1,
    IFLA_BROADCAST = 2,
    IFLA_IFNAME = 3,
    IFLA_MTU = 4,
    IFLA_LINK = 5,
    IFLA_QDISC = 6,
    IFLA_STATS = 7,
    IFLA_COST = 8,
    IFLA_PRIORITY = 9,
    IFLA_MASTER = 10,
    IFLA_WIRELESS = 11,
    IFLA_PROTINFO = 12,
    IFLA_TXQLEN = 13,
    IFLA_MAP = 14,
    IFLA_WEIGHT = 15,
    IFLA_OPERSTATE = 16,
    IFLA_LINKMODE = 17,
    IFLA_LINKINFO = 18,
    IFLA_NET_NS_PID = 19,
    IFLA_IFALIAS = 20,
    IFLA_NUM_VF = 21,
    IFLA_VFINFO_LIST = 22,
    IFLA_STATS64 = 23,
    IFLA_VF_PORTS = 24,
    IFLA_PORT_SELF = 25,
    IFLA_AF_SPEC = 26,
    IFLA_GROUP = 27,
    IFLA_NET_NS_FD = 28,
    IFLA_EXT_MASK = 29,
    IFLA_PROMISCUITY = 30,
    IFLA_NUM_TX_QUEUES = 31,
    IFLA_NUM_RX_QUEUES = 32,
    IFLA_CARRIER = 33,
    IFLA_PHYS_PORT_ID = 34,
    IFLA_CARRIER_CHANGES = 35,
    IFLA_PHYS_SWITCH_ID = 36,
    IFLA_LINK_NETNSID = 37,
    IFLA_PHYS_PORT_NAME = 38,
    IFLA_PROTO_DOWN = 39,
    IFLA_GSO_MAX_SEGS = 40,
    IFLA_GSO_MAX_SIZE = 41,
    IFLA_PAD = 42,
    IFLA_XDP = 43,
    __IFLA_MAX = 44,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed3 {
    IFLA_INET_UNSPEC = 0,
    IFLA_INET_CONF = 1,
    __IFLA_INET_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed4 {
    IFLA_INET6_UNSPEC = 0,
    IFLA_INET6_FLAGS = 1,
    IFLA_INET6_CONF = 2,
    IFLA_INET6_STATS = 3,
    IFLA_INET6_MCAST = 4,
    IFLA_INET6_CACHEINFO = 5,
    IFLA_INET6_ICMP6STATS = 6,
    IFLA_INET6_TOKEN = 7,
    IFLA_INET6_ADDR_GEN_MODE = 8,
    __IFLA_INET6_MAX = 9,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum in6_addr_gen_mode {
    IN6_ADDR_GEN_MODE_EUI64 = 0,
    IN6_ADDR_GEN_MODE_NONE = 1,
    IN6_ADDR_GEN_MODE_STABLE_PRIVACY = 2,
    IN6_ADDR_GEN_MODE_RANDOM = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed5 {
    IFLA_BR_UNSPEC = 0,
    IFLA_BR_FORWARD_DELAY = 1,
    IFLA_BR_HELLO_TIME = 2,
    IFLA_BR_MAX_AGE = 3,
    IFLA_BR_AGEING_TIME = 4,
    IFLA_BR_STP_STATE = 5,
    IFLA_BR_PRIORITY = 6,
    IFLA_BR_VLAN_FILTERING = 7,
    IFLA_BR_VLAN_PROTOCOL = 8,
    IFLA_BR_GROUP_FWD_MASK = 9,
    IFLA_BR_ROOT_ID = 10,
    IFLA_BR_BRIDGE_ID = 11,
    IFLA_BR_ROOT_PORT = 12,
    IFLA_BR_ROOT_PATH_COST = 13,
    IFLA_BR_TOPOLOGY_CHANGE = 14,
    IFLA_BR_TOPOLOGY_CHANGE_DETECTED = 15,
    IFLA_BR_HELLO_TIMER = 16,
    IFLA_BR_TCN_TIMER = 17,
    IFLA_BR_TOPOLOGY_CHANGE_TIMER = 18,
    IFLA_BR_GC_TIMER = 19,
    IFLA_BR_GROUP_ADDR = 20,
    IFLA_BR_FDB_FLUSH = 21,
    IFLA_BR_MCAST_ROUTER = 22,
    IFLA_BR_MCAST_SNOOPING = 23,
    IFLA_BR_MCAST_QUERY_USE_IFADDR = 24,
    IFLA_BR_MCAST_QUERIER = 25,
    IFLA_BR_MCAST_HASH_ELASTICITY = 26,
    IFLA_BR_MCAST_HASH_MAX = 27,
    IFLA_BR_MCAST_LAST_MEMBER_CNT = 28,
    IFLA_BR_MCAST_STARTUP_QUERY_CNT = 29,
    IFLA_BR_MCAST_LAST_MEMBER_INTVL = 30,
    IFLA_BR_MCAST_MEMBERSHIP_INTVL = 31,
    IFLA_BR_MCAST_QUERIER_INTVL = 32,
    IFLA_BR_MCAST_QUERY_INTVL = 33,
    IFLA_BR_MCAST_QUERY_RESPONSE_INTVL = 34,
    IFLA_BR_MCAST_STARTUP_QUERY_INTVL = 35,
    IFLA_BR_NF_CALL_IPTABLES = 36,
    IFLA_BR_NF_CALL_IP6TABLES = 37,
    IFLA_BR_NF_CALL_ARPTABLES = 38,
    IFLA_BR_VLAN_DEFAULT_PVID = 39,
    IFLA_BR_PAD = 40,
    IFLA_BR_VLAN_STATS_ENABLED = 41,
    IFLA_BR_MCAST_STATS_ENABLED = 42,
    IFLA_BR_MCAST_IGMP_VERSION = 43,
    IFLA_BR_MCAST_MLD_VERSION = 44,
    __IFLA_BR_MAX = 45,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_bridge_id {
    pub prio: [__u8; 2usize],
    pub addr: [__u8; 6usize],
}
impl ::std::default::Default for ifla_bridge_id {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed6 { BRIDGE_MODE_UNSPEC = 0, BRIDGE_MODE_HAIRPIN = 1, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed7 {
    IFLA_BRPORT_UNSPEC = 0,
    IFLA_BRPORT_STATE = 1,
    IFLA_BRPORT_PRIORITY = 2,
    IFLA_BRPORT_COST = 3,
    IFLA_BRPORT_MODE = 4,
    IFLA_BRPORT_GUARD = 5,
    IFLA_BRPORT_PROTECT = 6,
    IFLA_BRPORT_FAST_LEAVE = 7,
    IFLA_BRPORT_LEARNING = 8,
    IFLA_BRPORT_UNICAST_FLOOD = 9,
    IFLA_BRPORT_PROXYARP = 10,
    IFLA_BRPORT_LEARNING_SYNC = 11,
    IFLA_BRPORT_PROXYARP_WIFI = 12,
    IFLA_BRPORT_ROOT_ID = 13,
    IFLA_BRPORT_BRIDGE_ID = 14,
    IFLA_BRPORT_DESIGNATED_PORT = 15,
    IFLA_BRPORT_DESIGNATED_COST = 16,
    IFLA_BRPORT_ID = 17,
    IFLA_BRPORT_NO = 18,
    IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19,
    IFLA_BRPORT_CONFIG_PENDING = 20,
    IFLA_BRPORT_MESSAGE_AGE_TIMER = 21,
    IFLA_BRPORT_FORWARD_DELAY_TIMER = 22,
    IFLA_BRPORT_HOLD_TIMER = 23,
    IFLA_BRPORT_FLUSH = 24,
    IFLA_BRPORT_MULTICAST_ROUTER = 25,
    IFLA_BRPORT_PAD = 26,
    IFLA_BRPORT_MCAST_FLOOD = 27,
    __IFLA_BRPORT_MAX = 28,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_cacheinfo {
    pub max_reasm_len: __u32,
    pub tstamp: __u32,
    pub reachable_time: __u32,
    pub retrans_time: __u32,
}
impl ::std::default::Default for ifla_cacheinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed8 {
    IFLA_INFO_UNSPEC = 0,
    IFLA_INFO_KIND = 1,
    IFLA_INFO_DATA = 2,
    IFLA_INFO_XSTATS = 3,
    IFLA_INFO_SLAVE_KIND = 4,
    IFLA_INFO_SLAVE_DATA = 5,
    __IFLA_INFO_MAX = 6,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed9 {
    IFLA_VLAN_UNSPEC = 0,
    IFLA_VLAN_ID = 1,
    IFLA_VLAN_FLAGS = 2,
    IFLA_VLAN_EGRESS_QOS = 3,
    IFLA_VLAN_INGRESS_QOS = 4,
    IFLA_VLAN_PROTOCOL = 5,
    __IFLA_VLAN_MAX = 6,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vlan_flags {
    pub flags: __u32,
    pub mask: __u32,
}
impl ::std::default::Default for ifla_vlan_flags {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed10 {
    IFLA_VLAN_QOS_UNSPEC = 0,
    IFLA_VLAN_QOS_MAPPING = 1,
    __IFLA_VLAN_QOS_MAX = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vlan_qos_mapping {
    pub from: __u32,
    pub to: __u32,
}
impl ::std::default::Default for ifla_vlan_qos_mapping {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed11 {
    IFLA_MACVLAN_UNSPEC = 0,
    IFLA_MACVLAN_MODE = 1,
    IFLA_MACVLAN_FLAGS = 2,
    IFLA_MACVLAN_MACADDR_MODE = 3,
    IFLA_MACVLAN_MACADDR = 4,
    IFLA_MACVLAN_MACADDR_DATA = 5,
    IFLA_MACVLAN_MACADDR_COUNT = 6,
    __IFLA_MACVLAN_MAX = 7,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum macvlan_mode {
    MACVLAN_MODE_PRIVATE = 1,
    MACVLAN_MODE_VEPA = 2,
    MACVLAN_MODE_BRIDGE = 4,
    MACVLAN_MODE_PASSTHRU = 8,
    MACVLAN_MODE_SOURCE = 16,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum macvlan_macaddr_mode {
    MACVLAN_MACADDR_ADD = 0,
    MACVLAN_MACADDR_DEL = 1,
    MACVLAN_MACADDR_FLUSH = 2,
    MACVLAN_MACADDR_SET = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed12 {
    IFLA_VRF_UNSPEC = 0,
    IFLA_VRF_TABLE = 1,
    __IFLA_VRF_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed13 {
    IFLA_VRF_PORT_UNSPEC = 0,
    IFLA_VRF_PORT_TABLE = 1,
    __IFLA_VRF_PORT_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed14 {
    IFLA_MACSEC_UNSPEC = 0,
    IFLA_MACSEC_SCI = 1,
    IFLA_MACSEC_PORT = 2,
    IFLA_MACSEC_ICV_LEN = 3,
    IFLA_MACSEC_CIPHER_SUITE = 4,
    IFLA_MACSEC_WINDOW = 5,
    IFLA_MACSEC_ENCODING_SA = 6,
    IFLA_MACSEC_ENCRYPT = 7,
    IFLA_MACSEC_PROTECT = 8,
    IFLA_MACSEC_INC_SCI = 9,
    IFLA_MACSEC_ES = 10,
    IFLA_MACSEC_SCB = 11,
    IFLA_MACSEC_REPLAY_PROTECT = 12,
    IFLA_MACSEC_VALIDATION = 13,
    IFLA_MACSEC_PAD = 14,
    __IFLA_MACSEC_MAX = 15,
}
pub const MACSEC_VALIDATE_MAX: macsec_validation_type =
    macsec_validation_type::MACSEC_VALIDATE_STRICT;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum macsec_validation_type {
    MACSEC_VALIDATE_DISABLED = 0,
    MACSEC_VALIDATE_CHECK = 1,
    MACSEC_VALIDATE_STRICT = 2,
    __MACSEC_VALIDATE_END = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed15 {
    IFLA_IPVLAN_UNSPEC = 0,
    IFLA_IPVLAN_MODE = 1,
    __IFLA_IPVLAN_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum ipvlan_mode {
    IPVLAN_MODE_L2 = 0,
    IPVLAN_MODE_L3 = 1,
    IPVLAN_MODE_L3S = 2,
    IPVLAN_MODE_MAX = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed16 {
    IFLA_VXLAN_UNSPEC = 0,
    IFLA_VXLAN_ID = 1,
    IFLA_VXLAN_GROUP = 2,
    IFLA_VXLAN_LINK = 3,
    IFLA_VXLAN_LOCAL = 4,
    IFLA_VXLAN_TTL = 5,
    IFLA_VXLAN_TOS = 6,
    IFLA_VXLAN_LEARNING = 7,
    IFLA_VXLAN_AGEING = 8,
    IFLA_VXLAN_LIMIT = 9,
    IFLA_VXLAN_PORT_RANGE = 10,
    IFLA_VXLAN_PROXY = 11,
    IFLA_VXLAN_RSC = 12,
    IFLA_VXLAN_L2MISS = 13,
    IFLA_VXLAN_L3MISS = 14,
    IFLA_VXLAN_PORT = 15,
    IFLA_VXLAN_GROUP6 = 16,
    IFLA_VXLAN_LOCAL6 = 17,
    IFLA_VXLAN_UDP_CSUM = 18,
    IFLA_VXLAN_UDP_ZERO_CSUM6_TX = 19,
    IFLA_VXLAN_UDP_ZERO_CSUM6_RX = 20,
    IFLA_VXLAN_REMCSUM_TX = 21,
    IFLA_VXLAN_REMCSUM_RX = 22,
    IFLA_VXLAN_GBP = 23,
    IFLA_VXLAN_REMCSUM_NOPARTIAL = 24,
    IFLA_VXLAN_COLLECT_METADATA = 25,
    IFLA_VXLAN_LABEL = 26,
    IFLA_VXLAN_GPE = 27,
    __IFLA_VXLAN_MAX = 28,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vxlan_port_range {
    pub low: __be16,
    pub high: __be16,
}
impl ::std::default::Default for ifla_vxlan_port_range {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed17 {
    IFLA_GENEVE_UNSPEC = 0,
    IFLA_GENEVE_ID = 1,
    IFLA_GENEVE_REMOTE = 2,
    IFLA_GENEVE_TTL = 3,
    IFLA_GENEVE_TOS = 4,
    IFLA_GENEVE_PORT = 5,
    IFLA_GENEVE_COLLECT_METADATA = 6,
    IFLA_GENEVE_REMOTE6 = 7,
    IFLA_GENEVE_UDP_CSUM = 8,
    IFLA_GENEVE_UDP_ZERO_CSUM6_TX = 9,
    IFLA_GENEVE_UDP_ZERO_CSUM6_RX = 10,
    IFLA_GENEVE_LABEL = 11,
    __IFLA_GENEVE_MAX = 12,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed18 {
    IFLA_PPP_UNSPEC = 0,
    IFLA_PPP_DEV_FD = 1,
    __IFLA_PPP_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed19 {
    IFLA_GTP_UNSPEC = 0,
    IFLA_GTP_FD0 = 1,
    IFLA_GTP_FD1 = 2,
    IFLA_GTP_PDP_HASHSIZE = 3,
    __IFLA_GTP_MAX = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed20 {
    IFLA_BOND_UNSPEC = 0,
    IFLA_BOND_MODE = 1,
    IFLA_BOND_ACTIVE_SLAVE = 2,
    IFLA_BOND_MIIMON = 3,
    IFLA_BOND_UPDELAY = 4,
    IFLA_BOND_DOWNDELAY = 5,
    IFLA_BOND_USE_CARRIER = 6,
    IFLA_BOND_ARP_INTERVAL = 7,
    IFLA_BOND_ARP_IP_TARGET = 8,
    IFLA_BOND_ARP_VALIDATE = 9,
    IFLA_BOND_ARP_ALL_TARGETS = 10,
    IFLA_BOND_PRIMARY = 11,
    IFLA_BOND_PRIMARY_RESELECT = 12,
    IFLA_BOND_FAIL_OVER_MAC = 13,
    IFLA_BOND_XMIT_HASH_POLICY = 14,
    IFLA_BOND_RESEND_IGMP = 15,
    IFLA_BOND_NUM_PEER_NOTIF = 16,
    IFLA_BOND_ALL_SLAVES_ACTIVE = 17,
    IFLA_BOND_MIN_LINKS = 18,
    IFLA_BOND_LP_INTERVAL = 19,
    IFLA_BOND_PACKETS_PER_SLAVE = 20,
    IFLA_BOND_AD_LACP_RATE = 21,
    IFLA_BOND_AD_SELECT = 22,
    IFLA_BOND_AD_INFO = 23,
    IFLA_BOND_AD_ACTOR_SYS_PRIO = 24,
    IFLA_BOND_AD_USER_PORT_KEY = 25,
    IFLA_BOND_AD_ACTOR_SYSTEM = 26,
    IFLA_BOND_TLB_DYNAMIC_LB = 27,
    __IFLA_BOND_MAX = 28,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed21 {
    IFLA_BOND_AD_INFO_UNSPEC = 0,
    IFLA_BOND_AD_INFO_AGGREGATOR = 1,
    IFLA_BOND_AD_INFO_NUM_PORTS = 2,
    IFLA_BOND_AD_INFO_ACTOR_KEY = 3,
    IFLA_BOND_AD_INFO_PARTNER_KEY = 4,
    IFLA_BOND_AD_INFO_PARTNER_MAC = 5,
    __IFLA_BOND_AD_INFO_MAX = 6,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed22 {
    IFLA_BOND_SLAVE_UNSPEC = 0,
    IFLA_BOND_SLAVE_STATE = 1,
    IFLA_BOND_SLAVE_MII_STATUS = 2,
    IFLA_BOND_SLAVE_LINK_FAILURE_COUNT = 3,
    IFLA_BOND_SLAVE_PERM_HWADDR = 4,
    IFLA_BOND_SLAVE_QUEUE_ID = 5,
    IFLA_BOND_SLAVE_AD_AGGREGATOR_ID = 6,
    IFLA_BOND_SLAVE_AD_ACTOR_OPER_PORT_STATE = 7,
    IFLA_BOND_SLAVE_AD_PARTNER_OPER_PORT_STATE = 8,
    __IFLA_BOND_SLAVE_MAX = 9,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed23 {
    IFLA_VF_INFO_UNSPEC = 0,
    IFLA_VF_INFO = 1,
    __IFLA_VF_INFO_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed24 {
    IFLA_VF_UNSPEC = 0,
    IFLA_VF_MAC = 1,
    IFLA_VF_VLAN = 2,
    IFLA_VF_TX_RATE = 3,
    IFLA_VF_SPOOFCHK = 4,
    IFLA_VF_LINK_STATE = 5,
    IFLA_VF_RATE = 6,
    IFLA_VF_RSS_QUERY_EN = 7,
    IFLA_VF_STATS = 8,
    IFLA_VF_TRUST = 9,
    IFLA_VF_IB_NODE_GUID = 10,
    IFLA_VF_IB_PORT_GUID = 11,
    IFLA_VF_VLAN_LIST = 12,
    __IFLA_VF_MAX = 13,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_mac {
    pub vf: __u32,
    pub mac: [__u8; 32usize],
}
impl ::std::default::Default for ifla_vf_mac {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_vlan {
    pub vf: __u32,
    pub vlan: __u32,
    pub qos: __u32,
}
impl ::std::default::Default for ifla_vf_vlan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed25 {
    IFLA_VF_VLAN_INFO_UNSPEC = 0,
    IFLA_VF_VLAN_INFO = 1,
    __IFLA_VF_VLAN_INFO_MAX = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_vlan_info {
    pub vf: __u32,
    pub vlan: __u32,
    pub qos: __u32,
    pub vlan_proto: __be16,
}
impl ::std::default::Default for ifla_vf_vlan_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_tx_rate {
    pub vf: __u32,
    pub rate: __u32,
}
impl ::std::default::Default for ifla_vf_tx_rate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_rate {
    pub vf: __u32,
    pub min_tx_rate: __u32,
    pub max_tx_rate: __u32,
}
impl ::std::default::Default for ifla_vf_rate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_spoofchk {
    pub vf: __u32,
    pub setting: __u32,
}
impl ::std::default::Default for ifla_vf_spoofchk {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_guid {
    pub vf: __u32,
    pub guid: __u64,
}
impl ::std::default::Default for ifla_vf_guid {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed26 {
    IFLA_VF_LINK_STATE_AUTO = 0,
    IFLA_VF_LINK_STATE_ENABLE = 1,
    IFLA_VF_LINK_STATE_DISABLE = 2,
    __IFLA_VF_LINK_STATE_MAX = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_link_state {
    pub vf: __u32,
    pub link_state: __u32,
}
impl ::std::default::Default for ifla_vf_link_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_rss_query_en {
    pub vf: __u32,
    pub setting: __u32,
}
impl ::std::default::Default for ifla_vf_rss_query_en {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed27 {
    IFLA_VF_STATS_RX_PACKETS = 0,
    IFLA_VF_STATS_TX_PACKETS = 1,
    IFLA_VF_STATS_RX_BYTES = 2,
    IFLA_VF_STATS_TX_BYTES = 3,
    IFLA_VF_STATS_BROADCAST = 4,
    IFLA_VF_STATS_MULTICAST = 5,
    IFLA_VF_STATS_PAD = 6,
    __IFLA_VF_STATS_MAX = 7,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_vf_trust {
    pub vf: __u32,
    pub setting: __u32,
}
impl ::std::default::Default for ifla_vf_trust {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed28 {
    IFLA_VF_PORT_UNSPEC = 0,
    IFLA_VF_PORT = 1,
    __IFLA_VF_PORT_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed29 {
    IFLA_PORT_UNSPEC = 0,
    IFLA_PORT_VF = 1,
    IFLA_PORT_PROFILE = 2,
    IFLA_PORT_VSI_TYPE = 3,
    IFLA_PORT_INSTANCE_UUID = 4,
    IFLA_PORT_HOST_UUID = 5,
    IFLA_PORT_REQUEST = 6,
    IFLA_PORT_RESPONSE = 7,
    __IFLA_PORT_MAX = 8,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed30 {
    PORT_REQUEST_PREASSOCIATE = 0,
    PORT_REQUEST_PREASSOCIATE_RR = 1,
    PORT_REQUEST_ASSOCIATE = 2,
    PORT_REQUEST_DISASSOCIATE = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed31 {
    PORT_VDP_RESPONSE_SUCCESS = 0,
    PORT_VDP_RESPONSE_INVALID_FORMAT = 1,
    PORT_VDP_RESPONSE_INSUFFICIENT_RESOURCES = 2,
    PORT_VDP_RESPONSE_UNUSED_VTID = 3,
    PORT_VDP_RESPONSE_VTID_VIOLATION = 4,
    PORT_VDP_RESPONSE_VTID_VERSION_VIOALTION = 5,
    PORT_VDP_RESPONSE_OUT_OF_SYNC = 6,
    PORT_PROFILE_RESPONSE_SUCCESS = 256,
    PORT_PROFILE_RESPONSE_INPROGRESS = 257,
    PORT_PROFILE_RESPONSE_INVALID = 258,
    PORT_PROFILE_RESPONSE_BADSTATE = 259,
    PORT_PROFILE_RESPONSE_INSUFFICIENT_RESOURCES = 260,
    PORT_PROFILE_RESPONSE_ERROR = 261,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ifla_port_vsi {
    pub vsi_mgr_id: __u8,
    pub vsi_type_id: [__u8; 3usize],
    pub vsi_type_version: __u8,
    pub pad: [__u8; 3usize],
}
impl ::std::default::Default for ifla_port_vsi {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed32 {
    IFLA_IPOIB_UNSPEC = 0,
    IFLA_IPOIB_PKEY = 1,
    IFLA_IPOIB_MODE = 2,
    IFLA_IPOIB_UMCAST = 3,
    __IFLA_IPOIB_MAX = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed33 { IPOIB_MODE_DATAGRAM = 0, IPOIB_MODE_CONNECTED = 1, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed34 {
    IFLA_HSR_UNSPEC = 0,
    IFLA_HSR_SLAVE1 = 1,
    IFLA_HSR_SLAVE2 = 2,
    IFLA_HSR_MULTICAST_SPEC = 3,
    IFLA_HSR_SUPERVISION_ADDR = 4,
    IFLA_HSR_SEQ_NR = 5,
    IFLA_HSR_VERSION = 6,
    __IFLA_HSR_MAX = 7,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct if_stats_msg {
    pub family: __u8,
    pub pad1: __u8,
    pub pad2: __u16,
    pub ifindex: __u32,
    pub filter_mask: __u32,
}
impl ::std::default::Default for if_stats_msg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed35 {
    IFLA_STATS_UNSPEC = 0,
    IFLA_STATS_LINK_64 = 1,
    IFLA_STATS_LINK_XSTATS = 2,
    IFLA_STATS_LINK_XSTATS_SLAVE = 3,
    IFLA_STATS_LINK_OFFLOAD_XSTATS = 4,
    __IFLA_STATS_MAX = 5,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed36 {
    LINK_XSTATS_TYPE_UNSPEC = 0,
    LINK_XSTATS_TYPE_BRIDGE = 1,
    __LINK_XSTATS_TYPE_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed37 {
    IFLA_OFFLOAD_XSTATS_UNSPEC = 0,
    IFLA_OFFLOAD_XSTATS_CPU_HIT = 1,
    __IFLA_OFFLOAD_XSTATS_MAX = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed38 {
    IFLA_XDP_UNSPEC = 0,
    IFLA_XDP_FD = 1,
    IFLA_XDP_ATTACHED = 2,
    IFLA_XDP_FLAGS = 3,
    __IFLA_XDP_MAX = 4,
}
